---
title: Algorithms
...

Algorithms
==========

## 0.

[我的算法学习之路 - Lucida](http://lucida.me/blog/on-learning-algorithms/) -<

:   基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环
    境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个
    stof（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一
    个版本发到师兄的邮箱，结果对方压根没鸟我。

    这件事对我产生了很大的震动——

    -   原来自己连百度实习面试都过不去。
    -   原来自己还是一个**编程弱逼**。
    -   原来自己还是一个**算法菜逼**。

    我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。

    从这个事情之后我变得特别理解那些造轮子的人——你要想想，如果你需要一个飞机轮子但
    市场上只有自行车轮子而且老板还催着你交工，你能怎么搞。

    实习实习着就到了研二暑假，接下来就是求职季。

    求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。

    现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢
    有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。

    我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的
    题面试官也不会问——事实上也是如此。

    **编程珠玑**&更多的编程珠玑

    没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。

    证明简单代码段的正确性是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写
    一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试
    官还能挑剔什么呢？

    之后就是各种面试，详情见之前的博客，总之就是**项目经历**、**纸上代码**加**正确
    性证明**这三板斧，摧枯拉朽。

    MIT教授Erik Demaine则更为直接：

    >   If you want to become a good programmer, you can spend 10 years
    >   programming, or spend 2 years programming and learning algorithms.

[9个offer，12家公司，35场面试，从微软到谷歌，应届计算机毕业生的2012求职之路 - _Luc_ - 博客园](http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html) -<

:   外企（Google、MS、Yahoo等）>国内互联网（阿里、腾讯、百度、网易等）>企事业单位（基本不考虑）

    我的微软mentor曾提到过，我的实习面试表现一般，但后来表现出的动手能力大大超出之
    前面试的预估，而有些面试表现很出色，问题对答如流的选手，入职之后反而不是很理想
    ，至少没有达到面试时发挥出的水准。

    这说明一个问题，就是**笔试面试，准备和不准备会差异很大**。如果你的简历不是那么NB，
    那就只能靠笔试和面试的加分撑场面。身边经常有同学纳闷这样代码都编不利索的傻屌都
    能进MS为什么我不能进，答案往往很简单：人家比你多准备了一个月。平时电脑上写程序
    可能很利索，笔试面试时在纸上写写试试你就知道什么叫拙计。

    IT公司的笔试和面试的题量都不大（相对于企事业单位和银行动辄上百道选择题的题量，
    算是很少），一般十几道选择题，三四道大题就算题量很大。但计算机的东西实在又是太
    多，程序设计、数据结构、算法设计、操作系统、体系结构、编译原理、数据库、软件工
    程等分支，编译的话太难（一千个码农里也没几个人能在纸上写一个最基础的递归下降
    LLParser），软件工程、体系结构、数据库这些太水（不是说这些分支没用，而是它们很
    难考察，尤其对应届生来说这些都是些文字游戏，比如说面向对象的三要素五原则，有个
    鸟用），这么一排除，再把数据结构和算法设计一合并，就剩下**程序设计**、**算法**和
    **操作系统**。没错，这三项搞定，国内外IT公司通杀。

    **Tips**

    -   重温之前自己做过的靠谱项目，并总结里面的关键难题和解决思路
    -   重读Programming Pearls和More Programming Pearls，并完成所有课后题
    -   独立解决编程之美里面的题目（国内不少企业选题用的这本书）
    -   完成Careercup里Amazon、Google和Microsoft这三个分类下面的前20页面试题
    -   完成TopCoder的数十道D1L2~D2L1难度区间的算法题目
    -   重读Computer Systems a Programmer's Perspective的关键章节，回顾里面的关键点

    从七月底开始一直到十一月，花了接近四个月，很多东西都是一边面试一边准备：**面试->发现盲点->修复盲点**。

    简历

    -   篇幅。控制在一页以内。倒不是说不能写两页，而是HR没时间看两页这么多。而且就
        我看过的几百封简历而言，凡是超过两页的没一个靠谱，有这么高的先验概率，HR才
        没工夫一个个筛，反正中国有的是人。
    -   重点。一定要有重点，做到让 HR 通过简历在 20 秒内确定你靠不靠谱。可以用加黑字体进行视觉引导。
    -   别字。千万不要出现错别字，别字简历一般直接干掉。一页的简历都能出问题，一般不会靠谱。

    但是研发的算法题是一样的，最后一道算法题很有意思，我花了一个多小时才想到利用组
    合数学里面的知识（多元一次方程非负解）给出设计方案，后来和面试官聊这道题时他们
    也挺吃惊，因为我的方案比他们的答案还要优化。

    微软：

    -   题型只有**二十道不定项选择题**，难度较难，要求在一小时四十分钟完成。难度较难，
        覆盖面非常广，从设计模式，算法分析，代码阅读到C++语言特性，甚至连冷门的函数
        式程序设计语言都有涉及。
    -   微软的笔试题目BT之处在于其独特的积分机制：答对了加分，不答无分，答错了倒扣。
        这就使得很多ds答完试卷感觉自我良好但实际已经被倒扣出翔。以最后一道题为例，
        答对了加7分，答错倒扣13分，相当于一下子损失20分。所以微软的笔试题会做就得
        做对，不会做就别蒙，要不更惨。
    -   此外，微软的笔试题是英文的，加上时间比较短，有些人题都读不完，有些 ds 连
        functional language是什么都不知道，自然败的很惨。

    从笔试题可以明显看出，国外的大型IT公司（比如雅虎，微软和谷歌等）并不在意你现在
    的skill set，而更看重你的potential，因此题目大多很基础，并具备相当的深度，以确
    保你对CS有深刻的理解并能够走的很远；而国内的IT公司（比如百度、搜狗和人人等）更
    看重你现在的skill set，因此会出现不少语言特性，OS操作之类的具体题目，以确保你能
    够以尽快的速度上手干活，至于能发展到啥程度他们就不care了。

    考虑到几乎所有的公司都有编程题目，也就是在纸上写代码，这里推荐几本相关书籍：

    -   1 **Elements of programming style** 2nd，写出良好风格的代码。纸上代码一
        般不长，但短短几行代码往往可以看出这个人的水准，风格很差的代码往往会被
        pass掉。
    -   2 **Algorithm design manual** 2nd，作为非ACM出身的码农，这本书比算导实
        用很多，课后题也很实在，对回溯，动态规划这些编程技巧讲的非常清楚。
    -   3 **C interfaces and implementation**，无论是面试还是笔试，一般都会用C
        写程序，这本书包含大量的工业级C代码，绝佳的参考和模仿素材。

    最后推荐下Elements of programming和Structure and interpretation of computer
    programs，这两本书难度很高，需要大量的时间阅读，不适合临场阅读准备，但读过后，
    写出的代码绝逼会上两个层次，这里我就不多介绍了。

## 1.

[九章算法班 - 硅谷顶尖 IT 企业一线工程师直播教学](http://www.jiuzhang.com/course/1/) -<

:   我当然没有报这个班，但从这个列表，可以制定自己的复习内容。

    -   无算法基础，或算法基础薄弱，不系统
    -   希望求职 Facebook, Google, Linkedin, Airbnb, Uber 等硅谷知名企业
    -   面试经验少或无面试经验，不知道与面试官如何正确的沟通和展现自己
    -   网上练习题目那么多，不知道该从哪些题开始准备
    -   获取最新面试动向
    -   认识一起找工作的其他小伙伴

    2016/7/31 上午9:30:00 1. Introducing Algorithm Interview && Coding Style【免费试听】 -<

    :   -   通过 strStr 这一道常见面试题讲解面试中的常见误区 -<

            :   用常规的循环来做的话，复杂度是 O(mn)，参考代码如下：

                ```cpp
                int strstr(char *str, char *sub)
                {
                    if ( !str || !sub) { return -1; }

                    int nstr = strlen(str);
                    int nsub = strlen(sub);
                    if ( nstr < nsub ) { return -1; }

                    int len = nstr - nsub;
                    int i,j;
                    for ( int i = 0; i <= len; ++i ) {
                        for ( int j = 0; j < nsub; ++j ) {
                            if ( str[i+j] != sub[j] ) {
                                break;
                            }
                        }
                        if ( j == nsub ) {
                            return i + 1;
                        }
                    }
                    return -1;
                }
                ```

                误区？：

                -   结果正确 v.s. 条理清晰
                -   代码风格
                -   分析、描述问题
                -   边界检查？
                -   难度？

                从面试者的角度来说，出题的目的？

                还可以用牛逼闪闪的 KMP 算法。参考 [从头到尾彻底理解KMP（2014年8月22日版） - 结构之法 算法之道 - 博客频道 - CSDN.NET](http://blog.csdn.net/v_july_v/article/details/7041827)。

                在一个字符串中找到第一个只出现一次的字符。如输入 abaccdeff，则输出 b。

                思路：

                #.  可以用 bitmap
                #.  可以排序，然后用 i，j 来判断。

        -   从面试官的角度分析面试的考察点 -<

            :   -   如果没有 strlen？要自己写一个？还是融汇在的自己代码里。
                -   输入参数上，`char *str` 改成 `const char *str` 是不是更好？
                -   参数命名上，str 和 sub 好不好？要不换成 haystack 和 needle 怎么样？
                -   int len = strlen(str) 这里 len 的类型换成 size_t 是不是更好？int 型最多表示
                    多长的字节？2^31-1/2^10(k)/2^10(m)/2^10(g) = 2^{31-30} = 2 GB。我猜完全没有必要用……

                上面的问题你怎么回答。

        -   从 Subset 中了解算法面试中模板的重要性 -<

            :   挺重要。

                >   同样动作重复 300 次，肌肉就会有记忆，而一个动作重复 600 次，脊椎就会有记忆。
                >
                >   --- 李小龙

        -   面试常见问题答疑

        -   refs and see also -<

            :   -   [程序员编程艺术：第四章、现场编写类似strstr/strcpy/strpbrk的函数 - 结构之法 算法之道 - 博客频道 - CSDN.NET](http://blog.csdn.net/v_JULY_v/article/details/6417600)

    2016/8/6 上午9:30:00 2. 二分搜索 Binary Search -<

    :   -   学习 Binary Search 的通用模板，不再死循环 -<

            :   ```cpp
                int binary_search( int array[], int length, int value )
                {
                    // 这两个判断不必要
                    // if( length <= 0 ) { return -1; }
                    // if( length == 1 ) { return array[0] == value ? 0: -1; }

                    int low = 0;
                    int high = length-1;
                    int mid;
                    while( low <= high ) {
                        mid = (low+high)/2;
                        if( array[mid] == value ) {
                            return mid;
                        } else if( array[mid] > value ) {
                            high = mid-1;
                        } else {
                            low  = mid+1;
                        }
                    }
                    return -1;
                }
                ```

                什么情况下，mid-1 和 mid+1 不越界？length > 1。
                但还好有 left <= right 的判断，所以越界后，while 进不去。

                感受一下 mid 的位置 -<

                :   ```
                    中间有奇数个数字
                    [   0,  1,  2,  3,  4,  ... ]
                        ^       *       ^

                    [   0,  1,  2,  3,  4,  5,  ... ]
                            ^       *       ^

                    中间有偶数个数字
                    [   0,  1,  2,  3,  4,  5,  ... ]
                        ^       *           ^

                    [   0,  1,  2,  3,  4,  5,  6,  ... ]
                            ^       *           ^

                    中间啥都没有
                    [   0,  1,  ... ]
                        ^   ^
                        *

                    [   0,  ... ]
                        ^
                        ^
                        *
                    ```

                    总之因为 (left+right)/2 是向下 round（floor）。

                    需要注意的是 -3/2 = -1.5 = -1，-1/2 = -0.5 = 0；可见是向 0 round 的。

                    ```
                    如果有负的 index
                    [      -1,  0,  ... ]
                            ^   ^
                                *

                    [  -2, -1,  0,  ... ]
                        ^   ^
                            *
                    ```

                    但其实……怎么 round 是无所谓的。我这里只是让自己感受一下 mid 的
                    位置。面试的时候可以快速的找到中点（而不是用 index 算）。

        -   讲解 Search in Rotated Sorted Array 等 5-7 道高频二分搜索题 -<

            :   -   [33. Search in Rotated Sorted Array | LeetCode OJ](https://leetcode.com/problems/search-in-rotated-sorted-array/) -<

                    :   ![](http://whudoc.qiniudn.com/2016/20141025161730953.png)

                        图片来自：[【LeetCode】Search in Rotated Sorted Array 解题报告 - 跳出温水的青蛙 - 博客频道 - CSDN.NET](http://blog.csdn.net/ljiabin/article/details/40453607)。
                        chenhao 的代码实在……我没看懂。我的代码如下，已经通过了：

                        ```cpp
                        class Solution {
                        public:
                            int search(vector<int>& nums, int target) {
                                return search( nums, 0, nums.size(), target );
                            }
                            int search( vector<int> &nums, int left, int right, int target, int binarysearch = 0 ) {
                                if( binarysearch == 1 ) {
                                    int mid;
                                    while( left <= right ) {
                                        mid = (left+right)/2;
                                        if( target == nums[mid] ) {
                                            return mid;
                                        } else if( target < nums[mid] ) {
                                            right = mid-1;
                                        } else {
                                            left = mid+1;
                                        }
                                    }
                                    return -1;
                                }
                                if( left > right ) { return -1; }
                                if( left < 0 ) { left = 0; }
                                if( right >= nums.size() ) { right = nums.size()-1; }

                                int mid = (left+right)/2;
                                if( target == nums[left] ) { return left; }
                                if( target == nums[right] ) { return right; }
                                if( target == nums[mid] ) { return mid; }

                                if( nums[left] < nums[right] ) {
                                    //          case 1
                                    //
                                    //              /
                                    //             /
                                    //            /
                                    //           /
                                    //          /
                                    //
                                    if( target < nums[left] || target > nums[right] ) { return -1; }
                                    if( target < nums[mid] ) {
                                        return search( nums, left,  mid-1, target, 1 ); // ordinary binary search
                                    } else {
                                        return search( nums, mid+1, right, target, 1 ); // ordinary binary search
                                    }
                                } else if( nums[left] < nums[mid] /* && nums[left] > nums[right] */ ) {
                                    //          case 2
                                    //
                                    //            /
                                    //           /
                                    //          /
                                    //              /
                                    //             /
                                    //
                                    if( nums[left] < target && target < nums[mid] ) {
                                        return search( nums,  left, mid-1, target, 1 ); // ordinary binary search
                                    } else {
                                        return search( nums, mid+1, right, target );
                                    }
                                } else if( nums[right] > nums[mid] /* nums[left] > nums[right] */ ) {
                                    //          case 3
                                    //
                                    //           /
                                    //          /
                                    //              /
                                    //             /
                                    //            /
                                    //
                                    if( nums[mid] < target && target < nums[right] ) {
                                        return search( nums, mid+1, right, target, 1 ); // ordinary binary search
                                    } else {
                                        return search( nums,  left, mid-1, target );
                                    }
                                } else {
                                    //cout << "what...?!\n";
                                    return -1;
                                }
                            }
                        };
                        ```

                -   [81. Search in Rotated Sorted Array II | LeetCode OJ](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/) -<

                    :   Follow up for "Search in Rotated Sorted Array":

                        -   What if duplicates are allowed?
                        -   Would this affect the run-time complexity? How and why?
                        -   Write a function to determine if a given target is in the array.

                        ```cpp
                        class Solution {
                        public:
                            bool search(vector<int>& nums, int target) {
                                int low = 0;
                                int high = nums.size()-1;
                                int mid;
                                while( low <= high ) {
                                    if( nums[low] < nums[high] && (target<nums[low]||nums[high]<target) ) {
                                        return false;
                                    }
                                    // if dupilicates, remove the duplication
                                    while ( low < high && nums[low] == nums[high] ) {
                                        ++low;
                                    }
                                    mid = (low+high)/2;
                                    if ( nums[mid] == target || nums[low] == target || nums[high] == target ) {
                                        return true;
                                    }
                                    // left, not rotated
                                    if ( nums[low] < target && target < nums[mid] ) {
                                        high = mid-1;
                                        continue;
                                    }
                                    // right, not rotated
                                    if ( nums[mid] < target && target < nums[high] ) {
                                        low = mid+1;
                                        continue;
                                    }
                                    // rotated
                                    if  ( nums[low]  > nums[mid] ){ high = mid-1; continue; }
                                    if  ( nums[high] < nums[mid] ){ low  = mid+1; continue; }
                                    ++low;
                                }
                                return false;
                            }
                        };
                        ```

                -   [153. Find Minimum in Rotated Sorted Array | LeetCode OJ](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/) -<

                    :   Suppose a sorted array is rotated at some pivot unknown
                        to you beforehand.

                        (i.e., `0 1 2 4 5 6 7` might become `4 5 6 7 0 1 2`).

                        Find the minimum element.

                        You may assume no duplicate exists in the array.

                        ```cpp
                        class Solution {
                        public:
                            int findMin(vector<int>& nums) {
                                return findMin( nums, 0, nums.size()-1 );
                            }
                            int findMin( vector<int>& nums, int low, int high ) {
                                int mid = (low+high)/2;
                                if( mid == low || mid == high ) { return min( nums[low], nums[high] ); }
                                if( nums[low] < nums[high] ) {
                                    return nums[low];
                                } else {
                                    if( nums[low] < nums[mid] ) {
                                        return min( findMin( nums, mid+1, high ), nums[low] );
                                    } else {
                                        return min( findMin( nums, low, mid-1 ), nums[mid] );
                                    }
                                }
                            }
                        };
                        ```

                -   [154. Find Minimum in Rotated Sorted Array II | LeetCode OJ](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/) -<

                    :   The array may contain duplicates.

                        没有通过 ==

                        ```cpp
                        class Solution {
                        public:
                            int findMin(vector<int>& nums) {
                                return findMin( nums, 0, nums.size()-1 );
                            }
                            int findMin( vector<int>& nums, int low, int high ) {
                                if( low > high ) { return INT_MAX; }
                                int mid = (low+high)/2;
                                if( mid == low || mid == high ) { return min( nums[low], nums[high] ); }
                                if( nums[low] < nums[high] ) {
                                    return nums[low];
                                } else {
                                    while ( low < high && nums[low] == nums[high] ) {
                                        ++low;
                                    }
                                    mid = (low+high)/2;
                                    if( mid == low || mid == high ) { return min( nums[low], nums[high] ); }
                                    if( nums[low] < nums[mid] ) {
                                        return min( findMin( nums, mid+1, high ), nums[low] );
                                    } else {
                                        return min( findMin( nums, low, mid-1 ), nums[mid] );
                                    }
                                }
                            }
                        };
                        ```

                -   [108. Convert Sorted Array to Binary Search Tree | LeetCode OJ](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/){#lc108} -<

                    :   ```cpp
                        /**
                         * Definition for a binary tree node.
                         * struct TreeNode {
                         *     int val;
                         *     TreeNode *left;
                         *     TreeNode *right;
                         *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
                         * };
                         */
                        class Solution {
                        public:
                            TreeNode* sortedArrayToBST(vector<int>& nums) {

                                if(nums.size()==0){
                                    return NULL;
                                }
                                if(nums.size()==1){
                                    return new TreeNode(nums[0]);
                                }
                                int mid = nums.size()/2;

                                TreeNode *node = new TreeNode(nums[mid]);

                                vector<int>::const_iterator first = nums.begin();
                                vector<int>::const_iterator last  = nums.begin()+mid;

                                vector<int> v(first, last);
                                node->left = sortedArrayToBST(v);

                                if (mid==nums.size()-1){
                                    node->right = NULL;
                                } else {
                                    first = nums.begin()+mid+1;
                                    last = nums.end();
                                    vector<int> v(first, last);
                                    node->right = sortedArrayToBST(v);
                                }
                                return node;
                            }
                        };
                        ```

                        还有一个解答，见 [leetcode #108 answer 2](#lc108a2)

                        [109. Convert Sorted List to Binary Search Tree | LeetCode OJ](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)
                        和这个类似，我加了一层转换就 pass 了：

                        ```cpp
                        TreeNode* sortedListToBST(ListNode* head) {
                            vector<int> nums;
                            while( head ) {
                                nums.push_back( head->val );
                                head = head->next;
                            }
                            return sortedArrayToBST( nums );
                        }
                        ```

        -   refs and see also -<

            :   -   [Binary search algorithm - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)

    2016/8/7 上午9:30:00 3. 二叉树问题与分治算法 Binary Tree & Divide Conquer -<

    :   -   二叉树的深度优先遍历 Binary Tree DFS Traversal -<

            :   -   先序 / 中序 / 后序 Preorder / inorder / postorder -<

                    :   -   二叉树的节点定义 -<

                            :   ```cpp
                                struct TreeNode {
                                    int val;
                                    TreeNode *left;
                                    TreeNode *right;
                                    TreeNode( int x ) : val(x), left(nullptr), right(nullptr) { }
                                }
                                ```

                                递归版的都很容易：

                                ```cpp
                                void traversal( TreeNode *root, vector<int> &result ) {
                                    if( !root ) { return; }

                                    // 如果先序
                                    result.push_back( root->val );
                                    traversal( root->left,  result );
                                    traversal( root->right, result );

                                    // 中序和后序只是调整一下位置
                                }
                                ```

                        -   先序遍历 -<

                            :   -   用栈 -<

                                    :   ```cpp
                                        // Time: O(n), Space: O(n)
                                        vector<int> preorderTravesal( TreeNode *root ) {
                                            vector<int> result;
                                            stack<const TreeNode *> s;
                                            // 以后 if( root != nullptr ) 一律写成 if( root )。更简洁清晰
                                            if( root ) { s.push(root); }
                                            while( !s.empty() ) {
                                                const TreeNode *p = s.top();
                                                s.pop();
                                                result.push_back( p->val );

                                                if( p->right ) { s.push( p->right); }   // 这里不要疏忽了
                                                if( p->left  ) { s.push( p->left ); }
                                            }
                                            return result;
                                        }
                                        ```

                                -   Morris 先序遍历 -<

                                    :   参考 [Morris Traversal方法遍历二叉树（非递归，
                                            不用栈，`O(1)` 空间） - AnnieKim - 博客园](http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html)。

                                        要使用 O(1) 空间进行遍历，最大的难点在于，遍历
                                        到子节点的时候怎样重新返回到父节点（假设节点中
                                        没有指向父节点的p 指针），由于不能用栈作为辅助
                                        空间。为了解决这个问题，Morris 方法用到了线索二
                                        叉树（threaded binary tree）的概念。在 Morris
                                        方法中不需要为每个节点额外分配指针指向其前驱
                                        （predecessor）和后继节点（successor），只需要
                                        利用叶子节点中的左右空指针指向某种顺序遍历下的
                                        前驱节点或后继节点就可以了。

                                        ![moris preorder](http://images.cnitblog.com/blog/300640/201306/14221458-aa5f9e92cce743ccacbc735048133058.jpg)

                                        ```cpp
                                        // Time: O(n), Space: O(1)
                                        vector<int> preorderTraversal( TreeNode *root ) {
                                            vector<int> result;
                                            TreeNode *cur = root; *prev = nullptr;

                                            while( cur ) {
                                                if( cur->left ) {
                                                    result.push_back( cur->val );
                                                    prev    = cur;
                                                    cur     = cur->right;
                                                } else {
                                                    // 查找前驱
                                                    TreeNode *node = cur->left;
                                                    while( node->right && node->right != cur ) {
                                                        node = node->right;
                                                    }
                                                    if( !node->right ) {
                                                        result.push_back( cur->val );
                                                        node->right = cur;
                                                        prev        = cur;
                                                        cur         = cur->left;
                                                    } else {
                                                        node->right = nullptr;
                                                        cur = cur->right;
                                                    }
                                                }
                                            }
                                            return result;
                                        }
                                        ```

                        -   中序（inorder）遍历 :heart: -<

                            :   -   用栈 -<

                                    :   ```cpp
                                        vector<int> inorderTraveral( TreeNode *root ) {
                                            vector<int> result;
                                            stack<const TreeNode *> s;
                                            const TreeNode *p = root;
                                            while( !s.empty() || p ) {
                                                if( p ) {
                                                    s.push( p );                    // 计划处理 p（当前）
                                                    p = p->left;                    // 但先处理左节点
                                                } else {
                                                    p = s.top();                    // 处理 p（当前），它的左子树已经处理完了~
                                                    s.pop();
                                                    result.push_back( p->val );
                                                    p = p->right;                   // 然后移到右边
                                                }
                                            }
                                            return result;
                                        }
                                        ```

                                -   Moris -<

                                    :   ```cpp
                                        null
                                        ```

                                        ![红色是为了定位到某个节点，黑色线是为了
                                            找到前驱节点。](http://images.cnitblog.com/blog/300640/201306/15150628-5285f29bab234750a62e2309394b6e14.jpg)
                                        ![moris inorder](http://images.cnitblog.com/blog/300640/201306/14214057-7cc645706e7741e3b5ed62b320000354.jpg)

                        -   后序遍历 -<

                            :   -   用栈 -<

                                    :   ```cpp
                                        //  【思路】
                                        //
                                        //            Root    第一件事，从 root 到 leaf (left leaf) 一路 push 入栈，
                                        //             /      结果是从 root 移到了虚无之中。
                                        //            /
                                        //           /
                                        //         leaf       额，那就 pop 咯。
                                        //
                                        //         popped     对于这个 popped 出来的节点，它的 right 存在且没有处理过？
                                        //            \       1.  那再把它 push！然后把 right 当成 root 继续处理。
                                        //             \      2.  没有右边，那就是左右都处理完了，于是处理 popped。
                                        //              ?
                                        vector<int> postorderTraversal( TreeNode *root ) {
                                            vector<int> result;
                                            stack<const TreeNode *> s;
                                            const TreeNode *p = root, *q = nullptr;
                                            do {
                                                while( p ) {
                                                    s.push( p );
                                                    p = p->left;
                                                }
                                                q = nullptr;
                                                while( !s.empty() ) {
                                                    p = s.top();
                                                    s.pop();
                                                    if( p->right == q ) {
                                                        result.push_back( p->val );
                                                        q = p;
                                                    } else {
                                                        s.push( p );                // 计划当前结点
                                                        p = p->right;               // 但先处理右边
                                                    }
                                                }
                                            } while( !s.empty() );
                                            return result;
                                        }
                                        ```

                                -   Moris -<

                                    :   ```cpp
                                        null
                                        ```

                -   分治 Divide & Conquer -<

                    :   -   pow(x, n) -<

                            :   实现 power(x, n) 即 x^n

                                思路：

                                -   n 为奇数，x^n = x * x^{n-1}
                                -   n 为偶数，x^n = x^{n/2} * x^{n/2}

                                或者 x^n = x^{n/2} * x^{n/2} * x^{n%2}

                                ```cpp
                                // Time: O(logn), Space: O(1)
                                double pow( double x, int n ) {
                                    if( n < 0 ) { return 1.0 / pow( x, -n); }
                                    if( n == 0 ) { return 1; }
                                    double v = pow( x, n/2 );
                                    if( n%2 == 0 ) {
                                        return v * v;
                                    } else {
                                        return v * v * x;
                                    }
                                    // 写成 return n%2 ? v*v*x : v*v; 似乎没必要
                                    // （毕竟这个算法本来不长）
                                }
                                ```

                        -   sqrt(x) -<

                            :   ```cpp
                                int sqrt( int x ) {
                                    int left = 1, right = x / 2 + 1;
                                    int mid;
                                    if( x < 2 ) { return x; } // ?<0->..., 0->0, 1->1
                                    while( left <= right ) {
                                        mid = (left+right)/2;
                                        if( x / mid > mid ) {
                                            left = mid+1;
                                        } else if ( x / mid < mid) {
                                            right = mid-1;
                                        } else {
                                            // 9/3 == 3, 10/3 == 3, 15/3 > 3, so sqrt(15) = 4
                                            break; // return mid;
                                        }
                                    }
                                    return mid;
                                }
                                ```

                        -   refs and see also -<

                            :   -   [Divide and conquer algorithms - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)

                -   DFS 模板 Introduce DFS Template -<

                    :   DFS (depth-first search) 是深搜。

                        ```cpp
                        void dfs( type &input, type &path, type &result, int cur or gap ) {
                            if( 数据非法 ) { return 0; }            // 终止条件
                            if( cur == input.size() ) {
                                将 path 放入 result
                            }
                            if( 可以剪纸 ) { return; }
                            for( ... ) {    // 执行所有可能的扩展动作
                                执行动作，修改 path
                                dfs( input, step+1 or gap--, result );
                                恢复 path
                            }
                        }
                        ```

                        [Depth-first search - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Depth-first_search)

                        DFS 和回溯（backtracking）不一样。Backtracking = DFS + 减枝。

                        [Backtracking - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Backtracking)

                        [Pruning (algorithm) - Wikipedia, the free encyclopedia](http://inimino.org/~inimino/tests/js/tree_explorer/wikipedia/Pruning_(algorithm).html)

        -   二叉树的宽度优先遍历 Binary Tree BFS Traversal -<

            :   -   BFS 模板 Introduce BFS template -<

                    :   就是层序遍历（level order traversal）

                        -   递归版本 -<

                            :   ```cpp
                                // Time: O(n), Space: O(n)
                                vector<vector<int> > levelOrder( TreeNode *root ) {
                                    vector<vector<int> > result;
                                    traverse( root, 1, result );
                                    return result;
                                }

                                void traverse( TreeNode *root, size_t level, vector<vector<int> > &result ) {
                                    if( !root ) { return; }
                                    if( level > result.size() ) {
                                        result.push_back( vector<int>() );
                                        // 似乎也可以用 resize( level );
                                    }
                                    result[level-1].push_back( root->val );
                                    traverse( root->left,   level+1, result );
                                    traverse( root->right,  level+1, result );
                                }
                                ```

                        -   迭代版本 -<

                            :   ```cpp
                                // Time: O(n), Space: O(1)
                                vector<vector<int> > levelOrder( TreeNode *root ) {
                                    vector<vector<int> > result;
                                    queue<const TreeNode *> current, next;
                                    if( !root ) {
                                        return result;
                                    } else {
                                        current.push( root );
                                    }

                                    while( !current.empty() ) {
                                        vector<int> level;
                                        while( !current.empty() ) {
                                            TreeNode *node = current.front();
                                            current.pop();
                                            level.push_back( node->val );
                                            if( node->left  ) { next.push( node->left  ); }
                                            if( node->right ) { next.push( node->right ); }
                                        }
                                        result.push_back( level );
                                        swap( next, current );
                                    }
                                    return result;
                                }
                                ```

                -   refs and see also -<

                    :   -   [Breadth-First Traversal of a Tree](https://www.cs.bu.edu/teaching/c/tree/breadth-first/)
                        -   [Stack-based breadth-first search tree traversal](http://www.ibm.com/developerworks/aix/library/au-aix-stack-tree-traversal/index.html)

        -   二叉搜索树 Binary Search Tree -<

            :   -   What is BST -<

                    :   In computer science, binary search trees (BST), sometimes
                        called ordered or sorted binary trees, are a particular type of
                        containers: data structures that store "items" (such as
                        numbers, names etc.) in memory. They allow fast lookup,
                        addition and removal of items, and can be used to implement
                        either dynamic sets of items, or lookup tables that allow
                        finding an item by its key (e.g., finding the phone number of a
                        person by name).

                        The major advantage of binary search trees over other data
                        structures is that **the related sorting algorithms and search
                        algorithms such as in-order traversal can be very efficient**;
                        they are also easy to code.

                        Binary search trees are a fundamental data structure used to
                        construct more abstract data structures such as sets,
                        multisets, and associative arrays. Some of their disadvantages
                        are as follows:

                        -   The shape of the binary search tree depends entirely on the
                            order of insertions and deletions, and can become
                            **degenerate**. 树的结构跟数据插入删除顺序相关，可能退化。
                            解决方案是平衡二叉树。
                        -   When inserting or searching for an element in a binary
                            search tree, the key of each visited node has to be
                            compared with the key of the element to be inserted or
                            found. **不是随机访问。**
                        -   The keys in the binary search tree may be long and the run
                            time may increase. 如果 key 的比较很耗时，那就很糟。
                        -   After a long intermixed sequence of random insertion and
                            deletion, the expected height of the tree approaches square
                            root of the number of keys, √n, which grows much faster
                            than log n. **深度的预期是 sqrt(n) 比 最好的 log(n) 差很多。**
                            不过这一点好像还是在说 degenerate……

                        删除操作比较麻烦，分三种情况：

                        -   Deleting a node with no children: simply remove the node from the tree.
                        -   Deleting a node with one child: remove the node and replace it with its child.
                        -   Deleting a node with two children: call the node to be
                            deleted N. Do not delete N. Instead, choose either its
                            in-order successor node or its in-order predecessor node,
                            R. Copy the value of R to N, then recursively call delete
                            on R until reaching one of the first two cases. If you
                            choose in-order successor of a node, as right sub tree is
                            not NIL (Our present case is node has 2 children), then its
                            in-order successor is node with least value in its right
                            sub tree, which will have at a maximum of 1 sub tree, so
                            deleting it would fall in one of the first 2 cases.

                        ![Deleting a node with two children from a binary
                            search tree.  First the rightmost node in the left
                            subtree, the inorder predecessor 6, is identified.
                            Its value is copied into the node being deleted.
                            The inorder predecessor can then be easily deleted
                            because it has at most one child. The same method
                            works symmetrically using the inorder successor
                            labelled 9.这其实是在找一个比删掉节点（7）小（当然
                            是小）但经可能大的能够接替 7 的工作的节点。这个节点
                            在左边最右。这是如图所示。](https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Binary_search_tree_delete.svg/960px-Binary_search_tree_delete.svg.png)

                        ![Tree rotations are very common internal operations in binary
                            trees to keep perfect, or near-to-perfect, internal balance in the tree.](https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/BinaryTreeRotations.svg/450px-BinaryTreeRotations.svg.png)

                -   [Unique Binary Search Trees | LeetCode OJ](https://leetcode.com/problems/unique-binary-search-trees/) -<

                    :   Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

                        For example,
                        Given n = 3, there are a total of 5 unique BST's.

                        ```
                           1         3     3      2      1
                            \       /     /      / \      \
                             3     2     1      1   3      2
                            /     /       \                 \
                           2     1         2                 3
                        ```

                        数组为 1, 2, ... 以 i 为根节点的树，左子树由 `[i, i-1]` 构成，右子树为 `[i+1, n]` 构成。

                        ```
                        f(2) =  f(0) * f(1),    1 为根的情况
                             +  f(1) * f(0),    2 为根

                        f(3) =  f(0) * f(2),    1 为根
                             +  f(1) * f(1),    2 为根
                             +  f(2) * f(0),    3 为根
                        ```

                        递推公式为 `f(i) = sum{ f(k-1)*f(i-k) } for k = 0..i`，这是一个一维动态规划。

                        ```cpp
                        int numTrees( int n ) {
                            vector<int> f( n+1, 0 );
                            f[0] = f[1] = 1;
                            for( int i = 2; i <= n; ++i ) {
                                for( int k = 1; k <= n; ++k ) {
                                    f[i] += f[k-1] * f[i-k];
                                }
                            }
                            return f[n];
                        }
                        ```

                -   [Validate Binary Search Tree | LeetCode OJ](https://leetcode.com/problems/validate-binary-search-tree/) -<

                    :   ```cpp
                        bool isValidBST( TreeNode *root ) {
                            // leetcode 的 test case 里有 0xFFFFFFFF 和 0x7FFFFFFF，
                            // 简单考虑，直接变成 long long 再比较
                            return isValidBST( root, LLONG_MIN, LLONG_MAX );
                        }

                        bool isValidBST( TreeNode *root, long long min, long long max ) {
                            if( !root ) { return true; }
                            long long val = root->val;
                            return val > min && val < max &&
                                   isValidBST( root->left, min, root->val ) &&
                                   isValidBST( root->right, root->val, max );
                        }
                        ```

                -   [Convert Sorted Array to Binary Search Tree | LeetCode OJ](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/){#lc108a2} -<

                    :   Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

                        这道题在本笔记 [leetcode #108](#lc108) 也有。思路是一样的，不过那边更直白。

                        ```cpp
                        TreeNode * sortedArrayToBST( vector<int> &nums ) {
                            return sortedArrayToBST( nums.begin(), nums.end() );
                        }
                        template<typename RandomAccessIterator>
                        TreeNode * sortedArrayToBST(
                            RandomAccessIterator first,
                            RandomAccessIterator last
                        ) {
                            const auto length = distance( first, last );
                            if( length <= 0 ) { return nullptr; }
                            auto mid = first + length/2;
                            TreeNode *root = new TreeNode( *mid );
                            root->left = sortedArrayToBST( first, mid );
                            root->right = sortedArrayToBST( mid+1, last );
                            return root;
                        }
                        ```

                        refs and see also

                        -   [Convert Sorted Array to Balanced Binary Search Tree (BST) – LeetCode](http://articles.leetcode.com/convert-sorted-array-into-balanced)

                -   [Convert Sorted List to Binary Search Tree | LeetCode OJ](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/) -<

                    :   这里和上面不同的是，list 不能随机存取。最省力的方法是，先把 list 转成 array……

                        不用这种化归的偷懒策略，有两种思路：

                        -   分治法，自顶向下 O(n^2)，O(logn)
                        -   自底向上 O(n)，O(logn)

                        refs and see also

                        -   [Convert Sorted List to Balanced Binary Search Tree (BST) – LeetCode](http://articles.leetcode.com/convert-sorted-list-to-balanced-binary/)

                -   refs and see also -<

                    :   -   [Binary Trees](http://cslibrary.stanford.edu/110/BinaryTrees.html)
                        -   [Binary search tree - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Binary_search_tree)

    2016/8/13 上午9:30:00 4. 动态规划 Dynamic Programming I -<

    :   -   [什么是动态规划？动态规划的意义是什么？ - 知乎](https://www.zhihu.com/question/23995189) -<

            :   动态规划中递推式的求解方法不是动态规划的本质。

                动态规划的本质，是对问题【**状态**】的定义和【**状态转移方程**】的定义。

                引自维基百科

                >   dynamic programming is a method for solving a complex
                >   problem by breaking it down into a collection of simpler
                >   subproblems.

                动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题
                能够以递推（或者说分治）的方式去解决。本题下的其他答案，大多都
                是在说递推的求解方法，但**如何拆分问题，才是动态规划的核心**。
                而拆分问题，靠的就是状态的定义和状态转移方程的定义。

                动态规划迷思

                :   -   “缓存”，“重叠子问题”，“记忆化”： -<

                        :   这三个名词，都是在阐述递推式求解的技巧。以
                            Fibonacci 数列为例，计算第 100 项的时候，需要计算第
                            99 项和 98 项；在计算第 101 项的时候，需要第 100 项
                            和第 99 项，这时候你还需要重新计算第 99 项吗？不需要，
                            你只需要在第一次计算的时候把它记下来就可以了。

                            上述的需要再次计算的“第 99 项”，就叫“重叠子问题”。如
                            果没有计算过，就按照递推式计算，如果计算过，直接使
                            用，就像“缓存”一样，这种方法，叫做“记忆化”，这是递
                            推式求解的技巧。这种技巧，通俗的说叫“花费空间来节省
                            时间”。都不是动态规划的本质，不是动态规划的核心。

                    -   “递归” -<

                        :   递归是递推式求解的方法，连技巧都算不上。

                    -   "无后效性"，“最优子结构” -<

                        :   上述的状态转移方程中，等式右边不会用到下标大于左边 i
                            或者 k 的值，这是"无后效性"的通俗上的数学定义，符合
                            这种定义的状态定义，我们可以说它具有“最优子结构”的
                            性质，在动态规划中我们要做的，就是找到这种“最优子结
                            构”。

                文艺的说，动态规划是寻找一种对问题的观察角度，让问题能够以递推
                （或者说分治）的方式去解决。**寻找看问题的角度**，才是动态规划
                中最耀眼的宝石！

                另一个回答：

                -   一个阶段的最优可以由前一个阶段的最优得到。
                -   如果一个阶段的最优无法用前一个阶段的最优得到呢？

                刚刚的情况实在太普遍，解决方法实在太暴力，有没有哪些情况可以避免如此的暴力呢？

                契机就在于**后效性**。

                有一类问题，看似需要之前所有的状态，其实不用。不妨也是拿最长上
                升子序列的例子来说明为什么他不必需要暴力搜索，进而引出动态规划
                的思路。（这其实是说你要仔细区分状态，那些是无所谓的状态，哪些
                是本质的必须要留意的状态。这也和上面的正确选择【状态】的定义一个意思。）

                这就可以纵容我们不需要记录之前所有的状态啊！既然我们的选择已经
                不受之前状态的组合的影响了，那时间复杂度自然也不是指数的了啊！
                虽然我们不在乎某序列之前都是什么元素，但我们还是需要这个序列的
                长度的。所以我们只需要记录以某个元素结尾的 LIS 长度就好！因此第
                i 个阶段的最优解只是由前 i-1 个阶段的最优解得到的，然后就得到了
                DP 方程：

                `LIS(i) = max{ LIS(j)+1 } for j<i & a[j] < a[i]`

                所以一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问
                题本身阶段间状态的转移方式决定的！

                -   每个阶段只有一个状态->递推；
                -   每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
                -   每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
                -   每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。

                >   每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到

                这个性质叫做**最优子结构**；

                >   而不管之前这个状态是如何得到的

                这个性质叫做**无后效性**。

        -   [Dynamic programming - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Dynamic_programming)

            :   Sometimes, applying memoization to the naive recursive
                algorithm (namely the one obtained by a direct translation of
                the problem into recursive form) already results in a dynamic
                programming algorithm with asymptotically optimal time
                complexity, but for optimization problems in general the
                optimal algorithm might require more sophisticated algorithms.
                Some of these may be recursive (and hence can be memoized) but
                parametrized differently from the naive algorithm. For other
                problems the optimal algorithm may not even be a memoized
                recursive algorithm in any reasonably natural sense. An example
                of such a problem is the Egg Dropping puzzle described below.

                ![Figure 1. Finding the shortest path in a graph using optimal
                    substructure; a straight line indicates a single edge; a
                    wavy line indicates a shortest path between the two
                    vertices it connects (other nodes on these paths are not
                    shown); the bold line is the overall shortest path from
                    start to goal.](https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Shortest_path_optimal_substructure.svg/250px-Shortest_path_optimal_substructure.svg.png)

                ![Fibonacci 序列的子问题示意图：使用有向无环图（DAG, directed acyclic graph）
                    而非树表示重复子问题的分解。为什么是 DAG 而不是树呢？答案就
                    是，如果是树的话，会有很多重复计算，下面有相关的解释。 ](https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Fibonacci_dynamic_programming.svg/162px-Fibonacci_dynamic_programming.svg.png)

                为避免重复计算，可将已经得到的子问题的解保存起来，当我们要解决
                相同的子问题时，重用即可。该方法即所谓的缓存（memoization，而不
                是存储 memorization，虽然这个词亦适合，姑且这么叫吧，这个单词太
                难翻译了，简直就是可意会不可言传，其意义是没计算过则计算，计算
                过则保存）。当我们确信将不会再需要某一解时，可以将其抛弃，以节
                省空间。在某些情况下，我们甚至可以提前计算出那些将来会用到的子
                问题的解。

                refs and see also

                -   [动态规划算法 - 游戏人生 - C++博客](http://www.cppblog.com/Fox/archive/2008/05/07/Dynamic_programming.html)

        -   动态规划算法的适用条件 -<

            :   必须满足如下三点：

                -   最优化原理：如果问题的最优解所包含的子问题的解也是最优的，
                    就称该问题具有最优子结构，即满足最优化原理。
                -   无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影
                    响。也就是说，某状态以后的过程不会影响以前的状态，只与当前
                    状态有关。
                -   有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段
                    决策中可能被多次使用到。（该性质并不是动态规划适用的必要条
                    件，但是如果没有这条性质，动态规划算法同其他算法相比就不具
                    备优势）

                refs and see also

                -   [动态规划的适用条件 - 和申的日志 - 网易博客](http://1985wanggang.blog.163.com/blog/static/776383320081052347452/)

        -   动态规划算法的四个解题要素 -<

            :   作为 Sia 粉（Sia Furler），我把它记作 sfia。

                -   状 态 State
                      ~ 灵感，创造力，存储小规模问题的结果
                -   方程 Function
                      ~ 状态之间的联系，怎么通过小的状态，来算大的状态
                -   初始化 Initialization
                      ~ 最极限的小状态是什么, 起点
                -   答案 Answer
                      ~ 最大的那个状态是什么，终点

        -   动规的两种实现方式：记忆化搜索 vs 循环递推

        -   面试中动态规划的常见类型 -<

            :   满足下面三个条件之一：

                -   求最大值、最小值
                -   判断是否可行
                -   统计方案个数

                则极有可能 是使用动态规划求解

                什么情况下不使用动态规划？

                满足下面三个条件之一：

                -   求出所有**具体**的方案而非方案**个数** http://www.lintcode.com/problem/palindrome-partitioning/
                -   输入数据是一个**集合**而不**序列**• http://www.lintcode.com/problem/longest-consecutive-sequence/
                -   暴力的算法已经是多项式级别，2^n → n^2 是 DP 擅长的事

                则极不可能使用动态规划求解

        -   leetcode 中几道动态规划题 -<

            :   -   [Triangle | LeetCode OJ](https://leetcode.com/problems/triangle/) -<

                    :   Given a triangle, find the minimum path sum from top to
                        bottom. Each step you may move to adjacent numbers on the
                        row below.

                        For example, given the following triangle

                        ```
                        [
                             [2],
                            [3,4],
                           [6,5,7],
                          [4,1,8,3]
                        ]
                        ```

                        The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

                        Note:

                        Bonus point if you are able to do this using only O(n)
                        extra space, where n is the total number of rows in the
                        triangle.

                        ```
                            类似于图像处理里的【直方图 vs. 累计直方图】，概率论里的【PDF，CDF】：

                              [2],                                    [2]
                             [3,4],                            [ 5 =(2+3), 6 =(2+4) ]
                            [6,5,7],                      [ 11 =(5+6),  10 =(5+5 )   13 =(6+7) ]
                           [4,1,8,3]                  [   15         11        18          16       ]
                                                                      ^
                                                                      +----got you

                        从下往上看呢？

                              | j = 0   1   2   3
                        ------+------------------------------------------------------------------------------
                        i = 0 |     2               |                   |                   |   11
                            1 |     3   4           |                   |   9   10          |   9   10
                            2 |     6   5   7       |   7   6   10      |   7   6   10      |   7   6   10
                            3 |     4   1   8   3   |   4   1   8   3   |   4   1   8   3   |   4   1   8   3
                        ```

                        首先，定义状态转移方程：`f(i,j) = min{ f(i+i,j), f(i+1,j+1)} + f(i,j) for j = 0..i, i = n-2..0`。

                        ```cpp
                        int minimumTotal( vector<vector<int>> &triangle ) {
                            for( int i = triangle.size() -2; i >= 0; --i ) {
                                for( int j = 0; j < i+1; ++j ) {
                                    vector<vector<int>> &t = triangle;
                                    t[i][j] += min(t[i+1][j], t[i+1][j+1]);
                                }
                            }
                            return triangle[0][0];
                        }
                        ```

                -   [Maximum Subarray | LeetCode OJ](https://leetcode.com/problems/maximum-subarray/) -<

                    :    Find the contiguous subarray within an array
                        (containing at least one number) which has the largest sum.

                        For example, given the array `[−2,1,−3,4,−1,2,1,−5,4]`,
                        the contiguous subarray `[4,−1,2,1]` has the largest sum = 6.

                        贯序地看，对于新加入数组的一个元素，我们有两种选择：

                        -   加入原来的 sub array，
                        -   新生成一个 sub array（原来的 sub array 为负）

                        `S[n]` 为序列，`S[j]` 为第 j 个元素（1 based）。
                        设状态 `f[j]` 表示以 `S[j]` 结尾的最大连续子序列和，则状态转移方程如下：

                        -   `f[j] = max( f[j-1]+S[j], S[j] ), j = 2..n, f[1] = S[1]`
                        -   `target = max{ f[j] }, j = 1..n`

                        代码：

                        ```cpp
                        // Time: O(n), Space: O(1)
                        int maxSubArray( vector<int> &nums ) {
                            int result = INT_MIN, f = 0;
                            for( int i = 0; i < nums.size(); ++i ) {
                                f = max( f+nums[i], nums[i] );
                                result = max( f, result );
                            }
                            return result;
                        }
                        ```

                -   [Minimum Path Sum | LeetCode OJ](https://leetcode.com/problems/minimum-path-sum/) -<

                    :   Given a m x n grid filled with non-negative numbers,
                        find a path from **top left** to **bottom right** which
                        minimizes the sum of all numbers along its path.

                        Note: You can only move either down or right at any
                        point in time.

                        状态转移方程：
                        `f[i][j] = min(f[i-1][j], f[i][j-1]) + grid(i,j)`

                        -   备忘录法 -<

                            :   ```cpp
                                class Solution {
                                public:
                                    int minPathSum( vector<vector<int>> &grid ) {
                                        const int m = grid.size();
                                        const int n = grid[0].size();
                                        this->f = vector<vector<int>>( m, vector<int>(n, -1) );
                                        return dfs( grid, m-1, n-1 );
                                    }
                                private:
                                    vector<vector<int>> f; // 缓存
                                private:
                                    int dfs( const vector<vector<int>> &grid, int x, int y ) {
                                        if( x < 0 || y < 0 )    { return INT_MAX; }
                                        if( x == 0 && y == 0 )  { return grid[0][0]; }
                                        return min( getOrUpdate(grid, x-1, y), getOrUpdate(grid, x, y-1) ) + grid[x][y];
                                    }
                                    int getOrUpdate( const vector<vector<int>> &grid, int x, int y ) {
                                        if( x < 0 || y < 0 )    { return INT_MAX; }
                                        if( f[x][y] >= 0 ) {
                                            return f[x][y];
                                        } else {
                                            return f[x][y] = dfs(grid,x,y);
                                        }
                                    }
                                };
                                ```

                        -   动态规划 -<

                            :   ```cpp
                                int minPathSum( vector<vector<int>> &grid ) {
                                    const int m = grid.size();
                                    const int n = grid[0].size();
                                    int f[m][n];
                                    f[0][0] = grid[0][0];
                                    for( int i = 1; i < m; ++i ) {
                                        f[i][0] = f[i-1][0] + grid[i][0];
                                    }
                                    for( int j = 1; j < n; ++j ) {
                                        f[0][j] = f[0][j-1] + grid[0][j];
                                    }
                                    for( int i = 1; i < m; ++i ) {
                                        for( int j = 1; j <n; ++j ) {
                                            f[i][j] = min( f[i-1][j], f[i][j-1] ) + grid[i][j];
                                        }
                                    }
                                    return f[m-1][n-1];
                                }
                                ```

                        -   动态规划 + 滚动数组 -<

                            :   ```cpp
                                int minPathSum( vector<vector<int>> &grid ) {
                                    const int m = grid.size();
                                    const int n = grid[0].size();

                                    int f[n];
                                    fill( f, f+n, INT_MAX );
                                    f[0] = 0;

                                    for( int i = 0; i < m; ++i ) {
                                        f[0] += grid[i][0];
                                        for( int j = 1; j < n; ++j ) {
                                            f[j] = min( f[j-1], f[j] ) + grid[i][j];
                                        }
                                    }
                                    return f[n-1];
                                }
                                ```

    2016/8/14 上午9:30:00 5. 动态规划 Dynamic Programming II -<

    :   -   面试中常见的动态规划类型 -<

            :   -   **坐标型动态规划 15%**
                    -   state:
                        -   f[x] 表示我从起点走到坐标x......
                        -   f[x][y] 表示我从起点走到坐标x,y......
                    -   function: 研究走到x,y这个点之前的一步
                    -   initialize: 起点
                    -   answer: 终点
                -   **序列型动态规划 30%**
                    -   state: f[i]表示前i个位置/数字/字符,第i个...
                    -   function: f[i] = f[j] ... j 是i之前的一个位置
                    -   initialize: f[0]..
                    -   answer: f[n]..
                        -   一般answer是f(n)而不是f(n-1)
                        -   因为对于n个字符,包含前0个字符(空串),前1个字符......前n个字符。
                -   **双序列动态规划 30%**
                -   划分型动态规划 10%
                -   背包型动态规划 10%
                -   区间型动态规划 5%

                >   如果不是跟坐标相关的动态规划, 一般有N个数/字符,就开N+1个位
                >   置的数组, 第0个位置单独留出来作初始化

        [Word Break 参考程序 Java/C++/Python](http://www.jiuzhang.com/solutions/word-break/) -<

        :   Given a string s and a dictionary of words dict, determine if s can
            be segmented into a space-separated sequence of one or more
            dictionary words. For example, given s = "leetcode", dict =
            ["leet", "code"].  Return true because "leetcode" can be segmented
            as "leet code".

            ```cpp
            public class Solution {
                private int getMaxLength(Set<String> dict) {
                    int maxLength = 0;
                    for (String word : dict) {
                        maxLength = Math.max(maxLength, word.length());
                    }
                    return maxLength;
                }

                public boolean wordBreak(String s, Set<String> dict) {
                    if (s == null || s.length() == 0) {
                        return true;
                    }

                    int maxLength = getMaxLength(dict);
                    boolean[] canSegment = new boolean[s.length() + 1];

                    canSegment[0] = true;
                    for (int i = 1; i <= s.length(); i++) {
                        canSegment[i] = false;
                        for (int lastWordLength = 1;
                                 lastWordLength <= maxLength && lastWordLength <= i;
                                 lastWordLength++) {
                            if (!canSegment[i - lastWordLength]) {
                                continue;
                            }
                            String word = s.substring(i - lastWordLength, i);
                            if (dict.contains(word)) {
                                canSegment[i] = true;
                                break;
                            }
                        }
                    }

                    return canSegment[s.length()];
                }
            }
            ```

            -   state: f[i]表示“前i”个字符能否被完美切分
            -   function: f[i] = OR{f[j] && j+1~i is a word}, 其中 j < i
            -   initialize: f[0] = true
            -   answer: f[n]

            注意:切分位置的枚举->单词长度枚举 O(NL 2 ), N: 字符串长度, L: 最长的单词的长度

        [Palindrome Partitioning II 参考程序 Java/C++/Python](http://www.jiuzhang.com/solutions/palindrome-partitioning-ii/)

        -   单序列动态规划（下） Sequnece DP

        -   双序列动态规划 Two Sequences DP -<

            :   -   state: f[i][j]代表了第一个sequence的前i个数字/字符,配上第二个sequence的前j个...
                -   function: f[i][j] = 研究第i个和第j个的匹配关系
                -   initialize: f[i][0] 和 f[0][i]
                -   answer: f[n][m]
                -   n = s1.length()
                -   m = s2.length()

        -   problems -<

            :   求Max, [Longest Common Subsequence 参考程序 Java/C++/Python](http://www.jiuzhang.com/solutions/longest-common-subsequence/) -<

                :   • http://www.lintcode.com/problem/longest-common-substring/

                    state: f[i][j]表示前i个字符配上前j个字符的LCS的长度
                    • function: f[i][j] = MAX(f[i-1][j], f[i][j-1], f[i-1][j-1] + 1) // A[i - 1] == B[j - 1]
                    •
                    = MAX(f[i-1][j], f[i][j-1])
                    // A[i - 1] != B[j - 1]
                    • intialize: f[i][0] = 0 f[0][j] = 0
                    • answer: f[n][m]

                求Min, [Edit Distance 参考程序 Java/C++/Python](http://www.jiuzhang.com/solutions/edit-distance/)

                求方案总数, [Distinct Subsequences 参考程序 Java/C++/Python](http://www.jiuzhang.com/solutions/distinct-subsequences/) -<

                :   -   state: f[i][j] 表示 S的前i个字符中选取T的前j个字符,有多少种方案
                    -   function: f[i][j] = f[i - 1][j] + f[i - 1][j - 1] // S[i-1] == T[j-1] = f[i - 1][j] // S[i-1] != T[j-1]
                    -   initialize: f[i][0] = 1, f[0][j] = 0 (j > 0)
                    -   answer: f[n][m] (n = sizeof(S), m = sizeof(T))

                求是否可行, [Interleaving String 参考程序 Java/C++/Python](http://www.jiuzhang.com/solutions/interleaving-string/)

                什么情况下可能使用/不用动态规划?

                -   最大值最小值/是否可行/方案总数
                -   求所有方案/集合而不是序列/指数级到多项式
                -   解决动态规划问题的四点要素
                -   状态,方程,初始化,答案
                -   三种面试常见的动态规划类别及状态特点
                -   坐标,单序列,双序列
                -   两招独孤九剑
                -   二维DP需要初始化第0行和第0列
                -   n个字符的字符串要开n+1个位置的数组

                其他类型的动态规划(算法强化班) -<

                :   背包类:

                    -   http://www.lintcode.com/problem/backpack/
                    -   http://www.lintcode.com/problem/backpack-ii/
                    -   http://www.lintcode.com/problem/minimum-adjustment-cost/
                    -   http://www.lintcode.com/problem/k-sum/

                    区间类:

                    -   http://www.lintcode.com/problem/coins-in-a-line-iii/
                    -   http://www.lintcode.com/problem/scramble-string/

                    划分类:

                    -   http://www.lintcode.com/problem/best-time-to-buy-and-sell-stock-iv/
                    -   http://www.lintcode.com/problem/maximum-subarray-iii/

    2016/8/20 上午9:30:00 6. 链表 Linked List -<

    :   -   介绍 Dummy Node 在链表问题中的运用 Introduce Dummy Node in Linked List
        -   你必须知道的几点 Linked List 的常用技巧 Basic skills in Linked List you
            should know
        -   两根指针算法 Two pointers
        -   常见问题讲解 Frequent Questions

    2016/8/21 上午9:30:00 7. 数组与数 Array & Numbers -<

    :   -   旋转排序数组相关问题与三步翻转法的运用 Rotated Sorted Array & 3-step Reversion
        -   两个排序数组的中位数 Median of Two Sorted Array
        -   子数组相关问题 SubArray
        -   两根指针与 x-sum 问题 Two Pointers & x-sum
        -   分割数组相关问题 Partition Array

    2016/8/27 上午9:30:00 8. 数据结构 Data Structure -<

    :   -   线性数据结构
            -   队列的原理、实现和运用 Queue
            -   栈的原理、实现和运用 Heap
            -   哈希表的原理、实现和运用 HashMap
        -   树形数据结构
            -   堆的原理、实现和运用 Heap

    2016/8/28 上午9:30:00 9. 图与搜索 Graph & Search -<

    :   -   图上的宽度优先搜索 Graph BFS
        -   拓扑排序 Topological Sorting
        -   组合类深度优先搜索 Combination Related DFS
        -   排列类深度优先搜索 Permutation Related DFS

[九章算法强化班 - 硅谷顶尖IT企业一线工程师直播教学](http://www.jiuzhang.com/course/5/) -<

:   2016/8/21 上午7:00:00 FLAG算法面试难度提高？如何准备？【免费试听】 -<

    :   -   各类 IT 企业的面试算法难度及风格
        -   如何解决中等难度以上的算法题
        -   如何解决 follow  up 问题
        -   Two sum
            -   1. Two sum follow up I
            -   2. Two sum follow up II - Triangle count
        -   Kth largest element
            -   1. 第 k 大元素的三层递进面试考察.
            -   2. 如何通过一道题区分 3 类面试者
            -   3. 剖析面试官面试的思路

    2016/8/28 上午7:00:00 数据结构 Data Structure (上) -<

    :   -   并查集
            -   1. 并查集的基本原理
            -   2.并查集的相关运用
        -   并查集的拓展（带路径压缩）
        -   并查集的运用
        -   Trie 树
            -   1. Trie 树的相关运用
        -   扫描线算法
            -   1. 扫描线的常规题目
            -   2. 扫描线和其他数据结构结合的拓展

    2016/8/29 上午7:00:00 数据结构 Data Structure (下) -<

    :   -   Heap的深入理解和运用
        -   Heap重要拓展：
            -   1. 带删除的堆hash-heap
            -   2. Trapping rain water
            -   3. Building Outline
        -   Median 问题拓展
        -   Sliding Windows问题总结
        -   双端队列Deque

    2016/9/4 上午7:00:00 两个指针 Two Pointers -<

    :   -   对撞型指针
            -   1. Two sum 类
            -   2. Partition 类
        -   前向型指针
            -   1. 窗口类
            -   2. 快慢类
        -   两个数组上的指针

    2016/9/5 上午7:00:00 动态规划 Dynamic Programming (上) -<

    :   -   记忆化搜索（区间动态规划、博弈类动态规划）
        -   背包类动态规划
        -   区间类动态规划

    2016/9/11 上午7:00:00 动态规划 Dynamic Programming (下) -<

    :   -   记忆化搜索拓展
            -   1. 区间动态规划
            -   2. 博弈类动态规划
        -   背包类动态规划
            -   1. BackPack I/II
            -   2. K sum
            -   3. Minimum Adjustment Cost

    2016/9/12 上午7:00:00 如何解决 follow up 问题 -<

    :   -   Peak Element I/II
        -   第 K 大
            -   1. 第 K 大
            -   2. 有序矩阵的第 K 大
            -   3. 两个数组乘积的第 K 大
            -   4. n 个数组第 K 大
            -   5. n 个数组多机第 K 大 (K 比较小)
            -   6. n 个数组多机第 K 大 (K 比较大)
        -   Subarray sum
            -   1. Subarray sum
            -   2. Submatrix sum
            -   3. Subarray Sum Closest
            -   4. Subarray sum II

aoapc-book -<

:   **第一部分：语言篇**

    -   第 1 章，程序设计入门 -<

        :   -   我们的目标是解决问题，而不是为了写程序而写程序，同时应保持简单
                （Keep It Simple and Stupid, KISS），而不是自己创造条件去展示编
                程技巧。

            -   三整数排序

                :   ```cpp
                    #include <stdio.h>

                    int main() {
                        int a, b, c, t;
                        scanf( "%d%d%d", &a, &b, &c );
                        if( a > b ) { t = a; a = b; b = t; } // a <= b
                        if( a > c ) { t = a; a = c; c = t; } // a <= c
                        if( b > c ) { t = b; b = c; c = t; } // a <= b <= c
                        printf( "%d %d %d\n", a, b, c );
                        return 0;
                    }
                    ```

    -   第 2 章，循环结构程序设计 -<

        :   -   重定向

                ```cpp
                freopen( "data.in",  "r", stdin  );
                freopen( "data.out", "w", stdout );
                ```

            -   编程不是看书看会的，也不是听课听会的，而是练会的。

    -   第 3 章，数组和字符串 -<

        :   -   蛇形填数 -<

                :   ```cpp
                    #include <stdio.h>
                    #include <string.h>
                    #define maxn 20
                    int a[maxn][maxn];

                    int main() {
                        int n, x, y, tot = 0;
                        while( 1 == scanf( "%d", &n ) && n > 0 && n < maxn ) {
                            memset( a, 0, sizeof(a) );
                            tot = a[x=0][y=n-1] = 1;
                            while( tot < n*n ) {
                                while( x+1 <  n && !a[x+1][y] ) { a[++x][y] = ++tot; }
                                while( y-1 >= 0 && !a[x][y-1] ) { a[x][--y] = ++tot; }
                                while( x-1 >= 0 && !a[x-1][y] ) { a[--x][y] = ++tot; }
                                while( y+1 <  n && !a[x][y+1] ) { a[x][++y] = ++tot; }
                            }
                            for( x = 0; x < n; ++x ) {
                                for( y = 0; y < n; ++y ) {
                                    printf( "%5d", a[x][y] );
                                }
                                printf( "\n" );
                            }
                        }
                        return 0;
                    }
                    ```

            -   最好在做一件事之前检查是不是可以做，而不要做完再后悔。
                因为“毁棋”往往比较麻烦。

            -   `if( strchr( s, c ) == NULL ) { ... }`{.cpp}

            -   `fgetc` 返回 int？因为 EOF（值为 -1）不容易转化成 char。

            -   回文词（Palindromes） -<

                :   输入中没有 "0"。

                    ```cpp
                    #include <stdio.h>
                    #include <string.h>
                    #include <ctype.h>
                    //                 ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789
                    const char *rev = "A   3  HIL JM O   2TUVWXY51SE Z  8 ";
                    const char *msg[] = {   "not a palindrome",
                                            "a regular palindrome",
                                            "a mirrored string",
                                            "a mirrored palindrome" };

                    char r( char ch ) {
                        if( isupper(ch) ) {
                            return rev[ch-'A'];
                        } else if( '0' < ch && ch <= '9' ) {
                            return rev[ch-'1'+26];
                        } else {
                            return 0; // then should not equal
                        }
                    }

                    int main() {
                        char s[30];
                        while( scanf( "%s", s ) == 1 ) {
                            int len = strlen(s);
                            int p = 1, m = 1;
                            // 不是 len/2，你说为什么呢？
                            for( int i = 0; i < (len+1)/2; ++i ) {
                                if(   s[i]  != s[len-1-i] ) { p = 0; }
                                if( r(s[i]) != s[len-1-i] ) { m = 0; }
                                if( !p && !m ) { break; }
                            }
                            printf( "%s -- is %s.\n\n", s, msg[m*2+p] );
                        }
                        return 0;
                    }
                    ```

                    编译运行：

                    ```bash
                    $ gcc palindromes.c -o palindromes -std=c99

                    $ cat input.txt
                    NOTAPALINDROME
                    ISAPALINILAPASI
                    2A3MEAS
                    ATOYOTA

                    $ cat input.txt | palindromes
                    NOTAPALINDROME -- is not a palindrome.

                    ISAPALINILAPASI -- is a regular palindrome.

                    2A3MEAS -- is a mirrored string.

                    ATOYOTA -- is a mirrored palindrome.
                    ```

            -   环状序列（Circular Sequence） -<

                :   ```
                    +--------->---------+
                    |  T  C    G       \|/
                    |              A    |
                    | C               G |
                    ^                   |
                    | G               T |
                    |     G    A  C     |
                    +-----<----^--------+
                                \
                                 +----- 最小从这里开始
                    ```

                    ```cpp
                    #include <stdio.h>
                    #include <string.h>
                    #define maxn 105

                    int less( const char *s, int p, int q ) {
                        int n = strlen(s);
                        for( int i = 0; i < n; ++i ) {
                            if( s[(p+i)%n] != s[(q+i)%n] ) {
                                return s[(p+i)%n] < s[(q+i)%n];
                            }
                        }
                        return 0; // equal
                    }

                    int main() {
                        char s[maxn];
                        while( 1 == scanf( "%s", s ) ) {
                            int ans = 0;
                            int n = strlen(s);
                            for( int i = 1; i < n; ++i ) {
                                if( less(s, i, ans) ) { ans = i; }
                            }
                            printf( "%s --> \"", s );
                            for( int i = 0; i < n; ++i ) {
                                putchar( s[(i+ans)%n] );
                            }
                            printf( "\"\n" );
                        }
                        return 0;
                    }
                    ```

    -   第 4 章，函数和递归 -<

        :   -   `typedef struct { ... } type;`

            -   骰子涂色

                :   rbgggr 和 rggbgr 一样。

                    ```
                                +-------------+
                               /             /|  +------------5
                              /      1      / | /
                             /             /  |/
                            +------------+/   |
                    3 ----> |            |    |
                            |            | 4  /
                            |     2      |   /
                            |            |  /
                            |            | /
                            +------------+/
                                  ^
                                  |
                                  +-- 6
                    ```

    -   第 5 章，C++ 与 STL 入门 -<

        :   -   大理石在哪儿？
            -   木块问题
            -   Unix ls -<

                :   buggy.

                    ```cpp
                    #include <iostream>
                    #include <string>
                    #include <algorithm>
                    using namespace std;

                    const int maxcol    = 60;
                    const int maxn      = 100+5;
                    string filenames[maxn];

                    void print( const string &s, int len, char extra ) {
                        cout<< s;
                        for( int i = 0; i < len-s.length(); ++i ) {
                            cout << extra;
                        }
                    }

                    int main() {
                        int n;
                        while( cin >> n ) {
                            int M = 0;
                            for( int i = 0; i < n; ++i ) {
                                cin >> filenames[i];
                                M = max( M, (int)filenames[i].length() );
                            }
                            int cols = (maxcol-M)/(M+2) + 1, rows = (n-1)/cols + 1;
                            print( "", 60, '-' );
                            cout << "\n";
                            sort( filenames, filenames+n );
                            for( int r = 0; r < rows; ++r ) {
                                for( int c = 0; c < cols; ++c ) {
                                    int idx = c * rows + r;
                                    if( idx < n ) {
                                        printf( filenames[idx],
                                                c == cols-1? M : M-2,
                                                ' ' );
                                    }
                                }
                                cout << "\n";
                            }
                        }
                        return 0;
                    }
                ```

    **第二部分：基础篇**

    -   第 6 章，数据结构基础 -<

        :   -   树，Tree -<

                :   输入的是中序和后序遍历

                    ```cpp
                    #include <iostream>
                    #include <string>
                    #include <sstream>
                    #include <algorithm>
                    #include <iterator>
                    #include <assert.h>
                    #include <stdio.h>
                    using namespace std;

                    const int maxv = 100 + 10;
                    int in_order    [   maxv    ];
                    int post_order  [   maxv    ];
                    int lch         [   maxv    ];
                    int rch         [   maxv    ];

                    int n;

                    bool read_list( int *a ) {
                        string line;
                        if( !getline( cin, line ) ) { return false; }
                        stringstream ss( line );
                        n = 0;
                        int x;
                        while( ss >> x ) { a[n++] = x; }
                        return n > 0;
                    }

                    //  in_order[L1..R1] 和 post_order[L2..R2] 建成一颗树，返回树根
                    int build( int L1, int R1, int L2, int R2 ) {
                        if( L1 > R1 ) { return 0; }
                        int root = post_order[ R2 ];
                        int p = L1;
                        while( in_order[p] != root ) { ++p; }
                        int cnt = p-L1;
                        lch[ root ] = build( L1, p-1, L2, L2+cnt-1 );
                        rch[ root ] = build( p+1, R1, L2+cnt, R2-1 );
                        return root;
                    }

                    string print( int root, string pad ) {
                        if( root == 0 ) { return pad; }
                        const static string space = "        ";
                        char buf[20];
                        sprintf( buf, "%d", root );
                        string result = pad + space + string(buf);
                        result += "\n";
                        result += print( lch[root], pad );
                        result += print( rch[root], pad+space+space );
                        return result;
                    }

                    int best, best_sum;

                    //          u -> root
                    void dfs( int u, int sum ) {
                        sum += u;
                        if( !lch[u] && !rch[u] ) { // leaf
                            if( sum < best_sum || (sum == best_sum && u < best) ) {
                                best = u;
                                best_sum = sum;
                            }
                        }
                        if( lch[u] ) { dfs( lch[u], sum ); }
                        if( rch[u] ) { dfs( rch[u], sum ); }
                    }

                    int main() {
                        while( read_list( in_order ) ) {
                            read_list( post_order );
                            build( 0, n-1, 0, n-1 );
                            best_sum = -1;
                            dfs( post_order[n-1], 0 );
                            cout << best << "\n";
                            cout << print( post_order[n-1], "" );
                            copy( lch, lch+n, ostream_iterator<int>(cout, " ") );
                            cout <<"\n";
                            copy( rch, rch+n, ostream_iterator<int>(cout, " ") );
                            cout <<"\n";
                        }
                        return 0;
                    }
                    ```

            -   天平 -<

                :   input:

                    ```
                    1

                    0 2 0 4
                    0 3 0 1
                    1 1 1 1
                    2 4 4 2
                    1 6 3 2
                    ```

                    ```cpp
                    #include <iostream>
                    using namespace std;

                    bool solve( int &W ) {
                        int W1, D1, W2, D2;
                        bool b1 = true, b2 = true;
                        cin >> W1 >> D1 >> W2 >> D2;
                        if( !W1 ) { b1 = solve( W1 ); }
                        if( !W2 ) { b2 = solve( W2 ); }
                        W = W1 + W2;
                        return b1 && b2 && (W1*D1==W2*D2);
                    }

                    int main() {
                        int T, W;
                        cin >> T;
                        while( T-- ) {
                            if( solve(W) ) {
                                cout << "YES\n";
                            } else {
                                cout << "No\n";
                            }
                            if( T ) { cout << "\n"; }
                        }
                        return 0;
                    }
                    ```

            -   Abbott 的复仇 -<

                :   ```cpp
                    // d[r][c][dir] 存储从初始状态到 (r,c,dir) 的最短长度，其父节点保存在
                    // p[r][c][dir]

                    const char *dirs  = "NEWS"; // north, east, west, south
                    const char *turns = "FLR";  // forward, left, right
                    int dir_id(  char c ) { return strchr(dirs, c) - dirs; }
                    int turn_id( char c ) { return strchr(turns, c) - turns; }

                    //                  N   E   W   S           //          +-----------> y
                    const int dr[] = { -1,  0,  1,  0 };        //          |
                    const int dc[] = {  0,  1,  0, -1 };        //          |
                                                                //          | x
                                                                //          v

                    Node walk( const Node &u, int turn ) {
                        int dir = u.dir;                        // turn = 0, forward
                        if( turn == 1 ) { dir = (dir+3)%4; }    // turn = 1, left, counter clockwise
                        if( turn == 2 ) { dir = (dir+1)%4; }    // turn = 2, right, clockwise
                        return Node( u.r + dr[dir], u.c + dc[dir], dir );
                    }

                    void solve() {
                        queue<Node> q;
                        memset( d, -1, sizeof(d) );
                        Node u( r1, c1, dir );
                        d[u.r][u.c][u.dir] = 0;
                        q.push( u );
                        while( !q.empty() ) {
                            Node u = q.front(); q.pop();
                            if( u.r == r2 && r.c == c2 ) { print_ans(u); return; }
                            for( int i = 0; i < 3; ++i ) {
                                Node v = walk( u, i );
                                if( has_edge[u.r][u.c][u.dir][i] &&
                                    inside(v.r, v.c) &&
                                    d[v.r][v.c][v.dir] < 0 ) {  // 以前没有处于这个姿态
                                    // advance
                                    d[v.r][v.c][v.dir] = d[u.r][u.c][u.dir] + 1;
                                    p[v.r][v.c][v.dir] = u;
                                    q.push( v );                // 当前位置总是再 stack 顶端存着
                                }
                            }
                        }
                        printf( "No Solution Possible.\n" );
                    }

                    void print_ans( Node u ) {
                        vector<Node> nodes;
                        for( ;; ) {
                            nodes.push_back( u );                   // 一路存起来
                            if( d[u.r][u.c][u.dir] == 0 ) break;    // origin
                            u = p[u.r][u.c][u.dir];                 // backtrace
                        }
                        nodes.push_back( Node(r0, c0, dir) );       // ???

                        int cnt = 0;
                        for( int i = nodes.size()-1; i >= 0; --i ) {
                            if( cnt % 10 == 0 ) { printf( " " ); }
                            printf( " (%d, %d)", nodes[i].r, nodes[i].c );
                            if( ++cnt % 10 == 0 ) {
                                printf( "\n" );
                            }
                        }
                        if( nodes.size() % 10 != 0 ) { printf( "\n" ); }
                    }
                    ```

    -   第 7 章，暴力求解法 -<

        :   ```

              y - x    ?dx == dy                                y + x    ? dx == -dy (dx+dy==0)
                  +----------------------------------> y            +-----------------------------------> y
                  |  0   1   2   3   4   5   6   7                  |  0   1   2   3   4   5   6   7
                  | -1   0   1   2   3   4   5   6                  |  1   2   3   4   5   6   7   8
                  | -2  -1   0   1   2   3   4   5                  |  2   3   4   5   6   7   8   9
                  | -3  -2  -1   0   1   2   3   4                  |  3   4   5   6   7   8   9  10
                  | -4  -3  -2  -1   0   1   2   3                  |  4   5   6   7   8   9  10  11
                  | -5  -4  -3  -2  -1   0   1   2                  |  5   6   7   8   9  10  11  12
                x | -6  -5  -4  -3  -2  -1   0   1               x  |  6   7   8   9  10  11  12  13
                  | -7  -6  -5  -4  -3  -2  -1   0                  |  7   8   9  10  11  12  13  14
                  v                                                 v
            ```

            ```cpp
            void search( int cur ) {
                if( cur == n ) {
                    ++tot;
                } else {
                    for( int i = 0; i < n; ++i ) {
                        int ok = 1;
                        C[cur] = i;
                        for( int j = 0; j < cur; ++j ) {
                            int dx = cur - j, dy = C[cur] - C[j];
                            if( C[cur] == C[j] || dx == dy || dy == -dy ) {
                                ok = 0; break;
                            }
                            if( ok ) { search(cur+1); }
                        }
                    }
                }
            }
            ```

            ```cpp
            void search( int cur ) {
                if( cur == n ) {
                    ++tot;
                } else {
                    for( int i = 0; i < n; ++i ) {
                        if( !vis[0][i] && !vis[1][cur+i] && !vis[2][cur-i+n] ) {
                            C[cur] = i;
                            // col         y-x=0           y+x=0
                            vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 1;
                            search( cur+1 );
                            vis[0][i] = vis[1][cur+i] = vis[2][cur-i+n] = 0;    // 改回来
                        }
                    }
                }
            }
            ```

    **第三部分：竞赛篇**

    -   第 8 章，高级算法设计
    -   第 9 章，动态规划初步
    -   第 10 章，数学概念与方法
    -   第 11 章，图论模型与算法
    -   第 12 章，高级专题

Programming Pearls -<

:   -   part-1 -<

        :   -   column-1 -<

                :   磁盘排序：对于一个提出的问题，不要未经思考就直接给出答案。
                    要先深入研究问题，搞清楚这个问题的特点，根据这个特点，可能
                    有更好的解决方案。然后用了 bitmap。

                    ```
                    // init
                    for i = [0, n)
                        bit[i] = 0
                    // assign
                    for each i in the input file
                        bit[i] = 1
                    for i = [0, n)
                        if bit[i] == 1
                            write i on the output file
                    ```

                    首先你要找到 the right problem。

                    -   the bitmap data structure：a dense set over a finite domain
                    -   multiple-pass algorithms: 多次读入输入，每次离目标近一点
                    -   a time-space tradeoff and one that isn't
                    -   a simple design：不多不少刚刚好，简单的设计 bug 少
                    -   stages of program design

            -   column-2 -<

                :   #1 找数字 -<

                    :   给定一个包含32位整数的顺序文件(sequential file)，它至多只能包含40亿(4 billion)个这样的
                        整数，并且整数的次序是随机的(in a random order)。请查找一个此文件中不存在的32
                        位整数。在有足够内存的情况下(with ample quantities of main memory)，你会如何解决这个问题？如果你
                        可以使用若干外部临时文件但可用主存却只有上百字节，你会如何解决这个问题？

                        -   Given a sequential file that contain at most 4x109
                            integers(32-bit) in random order, find a 32-bit
                            integer that is not in the file.
                        -   How would you solve it with ample main memory?  --
                            bitmap (232bits)
                        -   or using several external "scratch" files but only
                            a few hundred bytes of main memory? -- binary
                            search 二分查找

                        首先，只是说找一个。其实 missing 的有很多==（因为 32 bit 的整数有 2^32 (4,294,967,296)个，这里只有 4 billion 个数字，肯定有一些数没有。）

                        4 billion 内的数字都可以用 int 来表示，所以用 bitmap 的话，有 2^32 个 bit 就够了，
                        也就是 2^{32}/8 bytes = 2^{32-3=29=9+10+10} bytes = 2^9 MBytes = 512 MBytes.

                        类似二分查找。可以根据某一位（操作时，可以从最高位 到
                        最低位依次处理），把待处理的数据分成两部分。在一部分中，
                        此位为0，另一部分此位为1。

                        之后，分别统计落在两个部分的数的个数。（此时我们不考虑数据是否重复）

                        -   如果，没有缺失，那么这两部分数的个数应该是相等的。
                        -   如果，数据有缺失，那么两部分数可能相等，也可能不等
                            -   两部分相等的情况：两段都缺失，但缺失的个数相等
                            -   两部分不等的情况：一个缺一个不缺  或  都缺但缺的个数不同

                    #2 n=8, i=3, abcdefgh -> defghabc -<

                    :   ```
                        reverse( 0, i-1 );          // cbadefgh
                        reverse( i, n-1 );          // cbahgfed
                        reverse( 0, n-1 );          // defghabc
                        ```

                        作者还很巧妙的用翻手来解释这个方案。

                        这个 reverse 可以这个写：

                        ```cpp
                        // method 1
                        void reverse( char *str, int start, int end ) {
                            char tmp;
                            int mid = (start + end)/2;
                            for ( int i = start, j = end; i <= mid; ++i, --j ) {
                                tmp = str[i];
                                str[i] = str[j];
                                str[j] = tmp;
                            }
                        }

                        // method 2, I prefer this one
                        void reverse( char *str, int start, int end ) {
                            char tmp;
                            while( start < end ) {
                                tmp         =   str[start];
                                str[start]  =   str[end];
                                str[end]    =   tmp;
                                ++start;
                                --end;
                            }
                        }

                        // 但不管怎样，调用的时候不要把
                        reverse( str, 0, strlen(str)-1 );
                        // 写成
                        reverse( str, 0, strlen(str) );
                        ```

                    #3 pots, stop, tops -<

                    :   找 signature 是最重要的。

                    原则：

                    -   sorting
                    -   binary search
                    -   signatures

                    Problems

                    :   -   翻转句子中单词的顺序，但单词内字符的顺序不变 -<

                            :   句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。

                                方法：先分别对各个单词进行逆转，然后对整个句子进行逆转。

                                I love you. -> I evol .uoy -> you. love I

                                ```cpp
                                #include <stdio.h>
                                #include <string.h>

                                void reverse( char *s, int left, int right ) {
                                    char tmp;
                                    while( left < right ) {
                                        tmp       =  s[left];
                                        s[left]   =  s[right];
                                        s[right]  =  tmp;
                                        ++left;
                                        --right;
                                    }
                                }

                                void solve( char *s ) {
                                    int left = 0, right = 0, len = strlen(s);
                                    while( left < len && right < len ) {
                                        while( s[right] && s[right] != ' ' ) {
                                            ++right;
                                        }
                                        if( !s[right] && left < right-1 ) {
                                            reverse( s, left, right-1 );    // 最后一段
                                            break;
                                        }
                                        reverse( s, left, right-1 );
                                        left = right + 1;                   // 跳过连续空格
                                        while( s[left] == ' ' ) {
                                            ++left;
                                        }
                                        right = left + 1;
                                    }
                                    reverse( s, 0, len-1 );                 // 这个 len-1 千万不能是 len
                                }

                                int main() {
                                    char buf[100];
                                    sprintf( buf, "%s", "I love Sia Furler." );
                                    printf( "before: %s\n", buf );
                                    solve( buf );
                                    printf( "%s\n", buf );
                                }
                                ```

                                `Furler. Sia love I`

                        -   类似手机键盘

                            :   每个数字对应几个字母。按下数字键，就意味着多个
                                字符组合，有关这些字符组合的姓名和手机号就找到。
                                问题，如何实现一个以名字的按键编码为参数，并
                                返回所有可能的匹配名字的函数

                                方法：把名字对应的数字按键形成一个唯一的标识符，
                                值存入数字键对应的名字 `map<int,map<string> > rec;`

                        -   sequential file 里的 4,300,000,000 个 32-bit integers 中找 one that appears at least twice？

            -   column-3 -<

                :   `if( k == 500 ) c500++; `……如此蛋疼的代码。

                    信件模板。

                    Principles

                    -   Don't write a big program when a little one will do.
                    -   使用数组重新编写重复代码。
                    -   封装复杂结构。
                    -   尽可能使用高级工具。名字-值对，电子表格（二维数组），数据库，特定编程语言的强大的工具。
                    -   从数据得出程序的结构。(let data structure the program.)

            -   column-4 -<

                :   Knuth 说，46 年 binary search 的论文出来了，62 年，终于有一个 bug free 的实现==。

                    本章作者主要证明了二分搜索程序的正确性。

                    构造程序的正确性上来先要找到**断言**(assertions)，也
                    就是所谓的【循环不变式】，当然这个在实际程序中，只有靠经验了。找到断言，即可以勾勒
                    出，输入、程序变量和输出之间的关系，使得程序员可以准确阐述这些关系。拿二分来说，
                    就是如果元素t在数组中，那么它一定在range中。在之后所有的操作都要遵循该不变式。

                    接下来看程序的结构。

                    -   如果是顺序控制结构(sequential control structures)。则可以通过在语句之间添加断言并分别分析程序执行的每一步。
                    -   如果是选择控制结构(selection control structures)，则要对每一个分支进行结构的正确性证明。
                        选择每一个分支，使用断言来证明。例如，如果进入了 `if i > j` 的分支，
                        那么我们就可以断言 `i > j` 并且使用
                        这个事实来推倒出下一个断言。
                    -   最麻烦就是迭代控制结构(iteration control structures)。要证明循环的正确性，就必须为其确立3个性质。
                        -   初始化(initialization)：循环初次执行的时候不变式为真。
                        -   保持(preservation)：如果在某次迭代开始的时候以及循环体执行的时候
                            ，不变式为真，那么循环执行完毕的时候不变式仍然为真
                            。每次迭代都保持该不变式为真。
                        -   终止(termination)：循环能够终止，并且可以得到预期的结果，而且我
                            们必须用其他方法证明循环一定能终止。就像二分每次范
                            围都在减少，课后习题，豆子每次都在减少一个。

                        对于函数的正确性证明，首先要使用两个断言来陈述目的。

                        -   前置条件：调用该函数之前成立的状态。
                        -   后置条件的正确性有函数在终止时保证。

                        拿二分来说，前置条件是序列有序（二分），后置条件是找没有找到元素，返回位置。

                        如果在前置条件满足情况下调用函数，那么函数的执行将确立后置条件，这就是契约编程。

                        证明程序的正确性是一门学问，如果违反断言就指明了程序的错误所在。程序状态的断言对理解程序很有帮助。

                    ```cpp
                    int binary_search( int A[], int n, int target ) {
                        int low = 0, high = n;
                        int mid;
                        while( low <= high ) {
                            mid = (low+high)/2;
                            if( A[mid] < target ) {
                                low = mid+1;
                            } else if( A[mid] > target ) {
                                high = mid-1;
                            } else {
                                return mid;
                            }
                        }
                        return -1;
                    }
                    ```

            -   column-5 -<

                :   主要讲解如何保证编程的正确性。在程序中加入断言（assert(断言内容) //如果错误，则终止程序。否则正常执行）。

                    一些 debug 技巧？assert 什么的使用，自动化测试。

    -   part-2
        -   column-7
        -   column-8
        -   column-9
    -   part-3
        -   column-11
        -   column-12
        -   column-13
        -   column-14
        -   column-15

    -   refs and see also

        :   -   [《编程珠玑》---笔记。浏览此文，一窥此书。 - 菜鸟的自留地 - 博客频道 - CSDN.NET](http://blog.csdn.net/yang_yulei/article/details/36068789)
            -   [编程珠玑_第二章_啊哈 算法 - 思考，思考，再思考~ - 博客频道 - CSDN.NET](http://blog.csdn.net/insistgogo/article/details/7749328)
            -   [编程珠玑第四章 - chloe - 博客频道 - CSDN.NET](http://blog.csdn.net/omashion/article/details/11694141){.heart}

[VisuAlgo - visualising data structures and algorithms through animation](http://visualgo.net/) -<

:   nice site.

    -   冒泡排序 -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-17-58-bubble.gif)

    -   选择排序 -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-19-47-select.gif)

    -   插入排序 -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-22-49-insert.gif)

    -   归并排序 -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-24-32-merge.gif)

    -   快排 -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-25-47-quick.gif)

    -   随机快排 -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-26-57-rquick.gif)

    -   计数排序 -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-28-54-count.gif)

    -   基数排序 -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-34-41-radix.gif)

    -   create binary heap -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-45-26-create-binary-heap-Onlgn.gif)

            ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-46-26-create-binary-heap-On.gif)

    -   heap sort -<

        :   ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-52-11-heap-sort.gif)

    ![a](http://whudoc.qiniudn.com/2016/2016-08-06_10-58-31-pred.gif)
    ![b](http://whudoc.qiniudn.com/2016/2016-08-06_10-59-12-next.gif)
    ![c](http://whudoc.qiniudn.com/2016/2016-08-06_11-04-07.gif)
    ![d](http://whudoc.qiniudn.com/2016/2016-08-06_11-05-11-avl-balanced.gif)
    ![e](http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-07-06.png)
    ![f](http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-07-22.png)
    ![g](http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-08-17.png)
    ![h](http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-08-42.png)

## 2.

常见 C/C++ 函数 -<

:   -   `size_t strlen( const char *str )`{.cpp} -<

        :   ```cpp
            size_t strlen( const char *str )
            {
                const char *s = str;
                while( *s ) { ++s; }
                return s-str;
            }
            ```

            不要把 `while( *s ) { ++s; }` 写成 `while( *s++ ) { }`

            然而这里却可以把 `++` 写在 while 的判断里面：

            ```cpp
            size_t strlen( const char *str )
            {
                size_t i = 0;
                while( *str++ ) { ++i; }
                return i;
            }
            ```

            函数签名可以在 `man strlen` 或者 `man 3 strlen` 看到。

    -   `char * strcpy( char *to, const char *from )`{.cpp} -<

        :   ```cpp
            char * strcpy( char *to, const char *from  )
            {
                if ( !from && !to ) { return NULL; }
                char *p = to;
                while( (*p++=*from++) != 0 ) { }
                return to;
            }
            ```

            前面的判断似乎多余，因为我们不关心 to 是否有空间以及它原来的内容，
            我们也不需要知道 from 是否为 NULL（如果 NULL，那在 while 里面复制一
            个 NULL 就结束，也是符合预期的。）

    -   `int atoi( const char *str)`{.cpp} -<

        :   ```cpp
            int atoi( const char *str )
            {
                // TODO: handle overflow
                if ( !str ) { return 0; }

                int len = strlen( str );
                int sign = 1;

                const char *p = str;
                while ( *p == ' ' ) {
                    ++p;
                }

                if ( *p == '+' ) { sign = +1; ++p; }
                if ( *p == '-' ) { sign = -1; ++p; }

                int i = 0;
                while( p && '0' <= *p && *p <= '9' ) {
                    i = i * 10 + (*p - '0');
                    ++p;
                }

                return i*sign;
            }
            ```

    -   `const char * convert( char buf[], int value )`{.cpp} -<

        :   ```cpp
            #include <iostream>
            #include <algorithm>
            #include <stdio.h>

            const char* convert( char buf[], int value )
            {
                static char digits[19] =
                { '9', '8', '7', '6', '5', '4', '3', '2', '1', '0',
                    '1', '2', '3', '4', '5', '6', '7', '8', '9' };
                static const char *const zero = digits + 9; // zero 指向 '0'
                // works for -2147483648 .. 2147483647
                int i = value;
                char* p = buf;
                do {
                    // lsd - least significant digit
                    int lsd = i % 10; // lsd 可能小于 0
                    // 是向下取整还是向零取整?
                    *p++ = zero[lsd]; // 下标可能为负
                    i /= 10;
                } while (i != 0);
                if (value < 0) {
                    *p++ = '-';
                }
                *p = '\0';
                std::reverse(buf, p);
                return p; // p - buf 即为整数长度
            }

            int main() {
                char buf[50];
                int num;
                while( 1 == scanf( "%d", &num ) ) {
                    convert( buf, num );
                    printf( "%d -> \"%s\"\n", num, buf );
                }
            }
            ```

            上面的代码来自 chenshuo，但我总觉得这 19 个 digits 把事情弄复杂了。
            我的策略是，负数我就把它先转成正数：

            ```cpp
            const char* convert( char buf[], int value )
            {
                if( value < 0 ) {
                    buf[0] = '-';
                    return convert( buf+1, -value );
                }

                static char zero[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

                char* p = buf;
                do {
                    *p++ = zero[value%10];
                    value /= 10;
                } while (value != 0);
                *p = '\0';
                std::reverse(buf, p);
                return p;
            }
            ```

    -   `char * strchr( const char *s, int c )`{.cpp} -<

        :   ```cpp
            char * strchr( const char *s, int c )
            {
                while( *s ) {
                    if( *s == c ) {
                        return s;
                    } else {
                        ++s;
                    }
                }
                return s;
            }
            ```

            目测没有 bug。懒得测了。

    -   TODO: strncpy, strcmp, strcat -<

        :   ```cpp
            char * __cdecl strcat (char * dst,const char * src)
            {
                char * cp = dst;

                while( *cp )
                    cp++;                   /* find end of dst */

                while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

                return( dst );                  /* return dst */

            }

            int __cdecl strcmp (const char * src,const char * dst)
            {
                int ret = 0 ;

                while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
                    ++src, ++dst;

                if ( ret < 0 )
                    ret = -1 ;
                else if ( ret > 0 )
                    ret = 1 ;

                return( ret );
            }

            size_t __cdecl strlen (const char * str)
            {
                const char *eos = str;

                while( *eos++ ) ;

                return( (int)(eos - str - 1) );
            }

            char * __cdecl strncat (char * front,const char * back,size_t count)
            {
                char *start = front;

                while (*front++)
                    ;
                front--;

                while (count--)
                    if (!(*front++ = *back++))
                        return(start);

                    *front = '\0';
                    return(start);
            }

            int __cdecl strncmp (const char * first,const char * last,size_t count)
            {
                if (!count)
                    return(0);

                while (--count && *first && *first == *last)
                {
                    first++;
                    last++;
                }

                return( *(unsigned char *)first - *(unsigned char *)last );
            }

            /* Copy SRC to DEST.  */
            char *
            strcpy (dest, src)
            char *dest;
            const char *src;
            {
                reg_char c;
                char *__unbounded s = (char *__unbounded) CHECK_BOUNDS_LOW (src);
                const ptrdiff_t off = CHECK_BOUNDS_LOW (dest) - s - 1;
                size_t n;

                do
                {
                    c = *s++;
                    s[off] = c;
                }
                while (c != '\0');

                n = s - src;
                (void) CHECK_BOUNDS_HIGH (src + n);
                (void) CHECK_BOUNDS_HIGH (dest + n);

                return dest;
            }

            char * __cdecl strncpy (char * dest,const char * source,size_t count)
            {
                char *start = dest;

                while (count && (*dest++ = *source++))    /* copy string */
                    count--;

                if (count)                              /* pad out with zeroes */
                    while (--count)
                        *dest++ = '\0';

                    return(start);
            }
            ```

        refs and see also

            -   [程序员编程艺术：第四章、现场编写类似strstr/strcpy/strpbrk的函数 - 结构之法 算法之道 - 博客频道 - CSDN.NET](http://blog.csdn.net/v_JULY_v/article/details/6417600)

[程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦 - 结构之法 算法之道 - 博客频道 - CSDN.NET](http://blog.csdn.net/v_july_v/article/details/6543438)

[Bresenham's line algorithm - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)

Milo Yip 的博客 -<

:   -   [《编程之美: 求二叉树中节点的最大距离》的另一个解法 - Milo Yip - 博客园](http://www.cnblogs.com/miloyip/archive/2010/02/25/binary_tree_distance.html)

    -   [《编程之美：分层遍历二叉树》的另外两个实现 - Milo Yip - 博客园](http://www.cnblogs.com/miloyip/archive/2010/05/12/binary_tree_traversal.html)

    -   [面试题：检测点是否在扇形之内 - Milo Yip - 博客园](http://www.cnblogs.com/miloyip/archive/2013/04/19/3029852.html)

    -   [怎样判断平面上一个矩形和一个圆形是否有重叠？ - Milo Yip 的回答 - 知乎](https://www.zhihu.com/question/24251545/answer/27184960) -< -<

        :   ![](https://pic1.zhimg.com/31fcf0a6ba5b5b925d7d82dc5bc8a684_r.jpg)

            ![](https://pic2.zhimg.com/60b09b89d9b4eda3fe9bdb849ec5d5d1_r.jpg)

            最后要比较 u 和 r 的长度，若距离少于 r，则两者相交。可以只求 u 的长度平方是
            否小于 r 的平方。

[Dijkstra's algorithm - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)

-   [Sorting algorithm - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Sorting_algorithm)
-   [Red–black tree - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)
-   [Heap · Data Structure and Algorithm notes](http://algorithm.yuanbin.me/zh-hans/basics_data_structure/heap.html)

[五大常用算法：分治、动态规划、贪心、回溯和分支界定 - yapian8的专栏 - 博客频道 - CSDN.NET](http://blog.csdn.net/yapian8/article/details/28240973)

[soulmachine (Frank Dai)](https://github.com/soulmachine)

授人以鱼，不如授之以渔，何况自己都忘了，建议去看sedgewick的《算法》第四版平衡搜索树和红黑树部分，讲得非常清晰。

-   [Zenefits电面真题 & 解析 - 九章算法 - 知乎专栏](https://zhuanlan.zhihu.com/p/20348386?refer=jiuzhang)
-   [Red–black tree - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)
-   [Sorting algorithm - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Sorting_algorithm)
-   [cirosantilli/algorithm-cheat: Algorithm tutorials and simple implementations with unit tests.](https://github.com/cirosantilli/algorithm-cheat)
-   [4ker/aoapc-book: Automatically exported from code.google.com/p/aoapc-book](https://github.com/4ker/aoapc-book)
-   [4ker/ppearls: Programming Pearls Prep work](https://github.com/4ker/ppearls)
-   [4ker/programming_pearls: the codes of "programming pearls(2nd edition)"](https://github.com/4ker/programming_pearls)
