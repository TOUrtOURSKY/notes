---
title: Algorithms
...

Algorithms
==========

## 0.

[我的算法学习之路 - Lucida](http://lucida.me/blog/on-learning-algorithms/) -<

:   基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环
    境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个
    stof（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一
    个版本发到师兄的邮箱，结果对方压根没鸟我。

    这件事对我产生了很大的震动——

    -   原来自己连百度实习面试都过不去。
    -   原来自己还是一个**编程弱逼**。
    -   原来自己还是一个**算法菜逼**。

    我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。

    从这个事情之后我变得特别理解那些造轮子的人——你要想想，如果你需要一个飞机轮子但
    市场上只有自行车轮子而且老板还催着你交工，你能怎么搞。

    实习实习着就到了研二暑假，接下来就是求职季。

    求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。

    现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢
    有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。

    我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的
    题面试官也不会问——事实上也是如此。

    **编程珠玑**&更多的编程珠玑

    没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。

    证明简单代码段的正确性是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写
    一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试
    官还能挑剔什么呢？

    之后就是各种面试，详情见之前的博客，总之就是**项目经历**、**纸上代码**加**正确
    性证明**这三板斧，摧枯拉朽。

    MIT教授Erik Demaine则更为直接：

    >   If you want to become a good programmer, you can spend 10 years
    >   programming, or spend 2 years programming and learning algorithms.

[9个offer，12家公司，35场面试，从微软到谷歌，应届计算机毕业生的2012求职之路 - _Luc_ - 博客园](http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html) -<

:   外企（Google、MS、Yahoo等）>国内互联网（阿里、腾讯、百度、网易等）>企事业单位（基本不考虑）

    我的微软mentor曾提到过，我的实习面试表现一般，但后来表现出的动手能力大大超出之
    前面试的预估，而有些面试表现很出色，问题对答如流的选手，入职之后反而不是很理想
    ，至少没有达到面试时发挥出的水准。

    这说明一个问题，就是**笔试面试，准备和不准备会差异很大**。如果你的简历不是那么NB，
    那就只能靠笔试和面试的加分撑场面。身边经常有同学纳闷这样代码都编不利索的傻屌都
    能进MS为什么我不能进，答案往往很简单：人家比你多准备了一个月。平时电脑上写程序
    可能很利索，笔试面试时在纸上写写试试你就知道什么叫拙计。

    IT公司的笔试和面试的题量都不大（相对于企事业单位和银行动辄上百道选择题的题量，
    算是很少），一般十几道选择题，三四道大题就算题量很大。但计算机的东西实在又是太
    多，程序设计、数据结构、算法设计、操作系统、体系结构、编译原理、数据库、软件工
    程等分支，编译的话太难（一千个码农里也没几个人能在纸上写一个最基础的递归下降
    LLParser），软件工程、体系结构、数据库这些太水（不是说这些分支没用，而是它们很
    难考察，尤其对应届生来说这些都是些文字游戏，比如说面向对象的三要素五原则，有个
    鸟用），这么一排除，再把数据结构和算法设计一合并，就剩下**程序设计**、**算法**和
    **操作系统**。没错，这三项搞定，国内外IT公司通杀。

    **Tips**

    -   重温之前自己做过的靠谱项目，并总结里面的关键难题和解决思路
    -   重读Programming Pearls和More Programming Pearls，并完成所有课后题
    -   独立解决编程之美里面的题目（国内不少企业选题用的这本书）
    -   完成Careercup里Amazon、Google和Microsoft这三个分类下面的前20页面试题
    -   完成TopCoder的数十道D1L2~D2L1难度区间的算法题目
    -   重读Computer Systems a Programmer's Perspective的关键章节，回顾里面的关键点

    从七月底开始一直到十一月，花了接近四个月，很多东西都是一边面试一边准备：**面试->发现盲点->修复盲点**。

    简历

    -   篇幅。控制在一页以内。倒不是说不能写两页，而是HR没时间看两页这么多。而且就
        我看过的几百封简历而言，凡是超过两页的没一个靠谱，有这么高的先验概率，HR才
        没工夫一个个筛，反正中国有的是人。
    -   重点。一定要有重点，做到让 HR 通过简历在 20 秒内确定你靠不靠谱。可以用加黑字体进行视觉引导。
    -   别字。千万不要出现错别字，别字简历一般直接干掉。一页的简历都能出问题，一般不会靠谱。

    但是研发的算法题是一样的，最后一道算法题很有意思，我花了一个多小时才想到利用组
    合数学里面的知识（多元一次方程非负解）给出设计方案，后来和面试官聊这道题时他们
    也挺吃惊，因为我的方案比他们的答案还要优化。

    微软：

    -   题型只有**二十道不定项选择题**，难度较难，要求在一小时四十分钟完成。难度较难，
        覆盖面非常广，从设计模式，算法分析，代码阅读到C++语言特性，甚至连冷门的函数
        式程序设计语言都有涉及。
    -   微软的笔试题目BT之处在于其独特的积分机制：答对了加分，不答无分，答错了倒扣。
        这就使得很多ds答完试卷感觉自我良好但实际已经被倒扣出翔。以最后一道题为例，
        答对了加7分，答错倒扣13分，相当于一下子损失20分。所以微软的笔试题会做就得
        做对，不会做就别蒙，要不更惨。
    -   此外，微软的笔试题是英文的，加上时间比较短，有些人题都读不完，有些 ds 连
        functional language是什么都不知道，自然败的很惨。

    从笔试题可以明显看出，国外的大型IT公司（比如雅虎，微软和谷歌等）并不在意你现在
    的skill set，而更看重你的potential，因此题目大多很基础，并具备相当的深度，以确
    保你对CS有深刻的理解并能够走的很远；而国内的IT公司（比如百度、搜狗和人人等）更
    看重你现在的skill set，因此会出现不少语言特性，OS操作之类的具体题目，以确保你能
    够以尽快的速度上手干活，至于能发展到啥程度他们就不care了。

    考虑到几乎所有的公司都有编程题目，也就是在纸上写代码，这里推荐几本相关书籍：

    -   1 **Elements of programming style** 2nd，写出良好风格的代码。纸上代码一
        般不长，但短短几行代码往往可以看出这个人的水准，风格很差的代码往往会被
        pass掉。
    -   2 **Algorithm design manual** 2nd，作为非ACM出身的码农，这本书比算导实
        用很多，课后题也很实在，对回溯，动态规划这些编程技巧讲的非常清楚。
    -   3 **C interfaces and implementation**，无论是面试还是笔试，一般都会用C
        写程序，这本书包含大量的工业级C代码，绝佳的参考和模仿素材。

    最后推荐下Elements of programming和Structure and interpretation of computer
    programs，这两本书难度很高，需要大量的时间阅读，不适合临场阅读准备，但读过后，
    写出的代码绝逼会上两个层次，这里我就不多介绍了。

## 1.

[九章算法班 - 硅谷顶尖 IT 企业一线工程师直播教学](http://www.jiuzhang.com/course/1/) -<

:   我当然没有报这个班，但从这个列表，可以制定自己的复习内容。

    -   无算法基础，或算法基础薄弱，不系统
    -   希望求职 Facebook, Google, Linkedin, Airbnb, Uber 等硅谷知名企业
    -   面试经验少或无面试经验，不知道与面试官如何正确的沟通和展现自己
    -   网上练习题目那么多，不知道该从哪些题开始准备
    -   获取最新面试动向
    -   认识一起找工作的其他小伙伴

    2016/7/31 上午9:30:00 1. Introducing Algorithm Interview && Coding Style【免费试听】 -<

    :   -   通过 strStr 这一道常见面试题讲解面试中的常见误区 -<

            :   用常规的循环来做的话，复杂度是 O(mn)，参考代码如下：

                ```cpp
                int strstr(char *str, char *sub)
                {
                    if ( !str || !sub) { return -1; }

                    int nstr = strlen(str);
                    int nsub = strlen(sub);
                    if ( nstr < nsub ) { return -1; }

                    int len = nstr - nsub;
                    int i,j;
                    for ( int i = 0; i <= len; ++i ) {
                        for ( int j = 0; j < nsub; ++j ) {
                            if ( str[i+j] != sub[j] ) {
                                break;
                            }
                        }
                        if ( j == nsub ) {
                            return i + 1;
                        }
                    }
                    return -1;
                }
                ```

                误区？：

                -   结果正确 v.s. 条理清晰
                -   代码风格
                -   分析、描述问题
                -   边界检查？
                -   难度？

                从面试者的角度来说，出题的目的？

                还可以用牛逼闪闪的 KMP 算法。参考 [从头到尾彻底理解KMP（2014年8月22日版） - 结构之法 算法之道 - 博客频道 - CSDN.NET](http://blog.csdn.net/v_july_v/article/details/7041827)。

                在一个字符串中找到第一个只出现一次的字符。如输入 abaccdeff，则输出 b。

                思路：

                #.  可以用 bitmap
                #.  可以排序，然后用 i，j 来判断。

        -   从面试官的角度分析面试的考察点 -<

            :   -   如果没有 strlen？要自己写一个？还是融汇在的自己代码里。
                -   输入参数上，`char *str` 改成 `const char *str` 是不是更好？
                -   参数命名上，str 和 sub 好不好？要不换成 haystack 和 needle 怎么样？
                -   int len = strlen(str) 这里 len 的类型换成 size_t 是不是更好？int 型最多表示
                    多长的字节？2^31-1/2^10(k)/2^10(m)/2^10(g) = 2^{31-30} = 2 GB。我猜完全没有必要用……

                上面的问题你怎么回答。

        -   从 Subset 中了解算法面试中模板的重要性 -<

            :   挺重要。

                >   同样动作重复 300 次，肌肉就会有记忆，而一个动作重复 600 次，脊椎就会有记忆。
                >
                >   --- 李小龙

        -   面试常见问题答疑

        -   refs and see also -<

            :   -   [程序员编程艺术：第四章、现场编写类似strstr/strcpy/strpbrk的函数 - 结构之法 算法之道 - 博客频道 - CSDN.NET](http://blog.csdn.net/v_JULY_v/article/details/6417600)

    2016/8/6 上午9:30:00 2. 二分搜索 Binary Search -<

    :   -   学习 Binary Search 的通用模板，不再死循环

            :   ```cpp
                int binary_search( int array[], int length, int value )
                {
                    // 这两个判断不必要
                    // if( length <= 0 ) { return -1; }
                    // if( length == 1 ) { return array[0] == value ? 0: -1; }

                    int low = 0;
                    int high = length-1;
                    int mid;
                    while( low <= high ) {
                        mid = (low+high)/2;
                        if( array[mid] == value ) {
                            return mid;
                        } else if( array[mid] > value ) {
                            high = mid-1;
                        } else {
                            low  = mid+1;
                        }
                    }
                    return -1;
                }
                ```

                什么情况下，mid-1 和 mid+1 不越界？length > 1。
                但还好有 left <= right 的判断，所以越界后，while 进不去。

        -   讲解 Search in Rotated Sorted Array 等 5-7 道高频二分搜索题 -<

            :   -   [Search in Rotated Sorted Array | LeetCode OJ](https://leetcode.com/problems/search-in-rotated-sorted-array/) -<

                    :   ![](http://whudoc.qiniudn.com/2016/20141025161730953.png)

                        图片来自：[【LeetCode】Search in Rotated Sorted Array 解题报告 - 跳出温水的青蛙 - 博客频道 - CSDN.NET](http://blog.csdn.net/ljiabin/article/details/40453607)。
                        chenhao 的代码实在……我没看懂。我的代码如下，已经通过了：

                        ```cpp
                        class Solution {
                        public:
                            int search(vector<int>& nums, int target) {
                                return search( nums, 0, nums.size(), target );
                            }
                            int search( vector<int> &nums, int left, int right, int target ) {
                                if( left > right ) { return -1; }
                                if( left < 0 ) { left = 0; }
                                if( right >= nums.size() ) { right = nums.size()-1; }

                                int mid = (left+right)/2;
                                if( target == nums[left] ) { return left; }
                                if( target == nums[right] ) { return right; }
                                if( target == nums[mid] ) { return mid; }

                                if( nums[left] < nums[right] ) {
                                    // case 1
                                    if( target < nums[left] || target > nums[right] ) {
                                        return -1;
                                    }
                                    if( target < nums[mid] ) {
                                        return search( nums, left, mid-1, target );
                                    } else {
                                        return search( nums, mid+1, right, target );
                                    }
                                } else if( nums[mid] > nums[left] && nums[left] > nums[right] ) {
                                    // case 2
                                    if( nums[left] < target && target < nums[mid] ) {
                                        return search( nums, left, mid-1, target );
                                    } else {
                                        return search( nums, mid+1, right, target );
                                    }
                                } else if( nums[left] > nums[right] && nums[right] > nums[mid] ) {
                                    // case 3
                                    if( nums[mid] < target && target < nums[right] ) {
                                        return search( nums, mid+1, right, target );
                                    } else {
                                        return search( nums, left, mid-1, target );
                                    }
                                } else {
                                    //cout << "what...?!\n";
                                    return -1;
                                }
                            }
                        };
                        ```

                -   [Search in Rotated Sorted Array II | LeetCode OJ](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/) -<

                    :   Follow up for "Search in Rotated Sorted Array":

                        -   What if duplicates are allowed?
                        -   Would this affect the run-time complexity? How and why?
                        -   Write a function to determine if a given target is in the array.

                        ```cpp
                        // Follow up for "Search in Rotated Sorted Array":
                        // What if duplicates are allowed?
                        //
                        // Would this affect the run-time complexity? How and why?
                        //
                        // Write a function to determine if a given target is in the array.

                        // Using the same idea "Search in Rotated Sorted Array"
                        // but need be very careful about the following cases:
                        //   [3,3,3,4,5,6,3,3]
                        //   [3,3,3,3,1,3]
                        // After split, you don't know which part is rotated and which part is not.
                        // So, you have to skip the ducplication
                        //   [3,3,3,4,5,6,3,3]
                        //          ^       ^
                        //   [3,3,3,3,1,3]
                        //            ^ ^
                        class Solution {
                        public:
                            bool search(int A[], int n, int key) {
                                if (n<=0) return false;

                                if (n==1){
                                    return (A[0]==key) ? true : false;
                                }
                                int low=0, high=n-1;
                                while( low<=high ){

                                    if (A[low] < A[high] && ( key < A[low] || key > A[high]) ) {
                                         return false;
                                    }

                                    //if dupilicates, remove the duplication
                                    while (low < high && A[low]==A[high]){
                                        low++;
                                    }

                                    int mid = low + (high-low)/2;
                                    if ( A[mid] == key ) return true;

                                    //the target in non-rotated array
                                    if (A[low] < A[mid] && key >= A[low] && key< A[mid]){
                                        high = mid - 1;
                                        continue;
                                    }
                                    //the target in non-rotated array
                                    if (A[mid] < A[high] && key > A[mid] && key <= A[high] ){
                                        low = mid + 1;
                                        continue;
                                    }
                                    //the target in rotated array
                                    if (A[low] > A[mid] ){
                                        high = mid - 1;
                                        continue;
                                    }
                                    //the target in rotated array
                                    if (A[mid] > A[high] ){
                                        low = mid + 1;
                                        continue;
                                    }

                                    //reach here means nothing found.
                                    low++;
                                }
                                return false;
                            }
                        };
                        ```

        -   refs and see also -<

            :   -   [Binary search algorithm - Wikipedia, the free encyclopedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)

    2016/8/7 上午9:30:00 3. 二叉树问题与分治算法 Binary Tree & Divide Conquer -<

    :   -   二叉树的深度优先遍历 Binary Tree DFS Traversal
            -   先序 / 中序 / 后序 Preorder / inorder / postorder
            -   分治 Divide & Conquer
            -   DFS 模板 Introduce DFS Template
        -   二叉树的宽度优先遍历 Binary Tree BFS Traversal
            -   BFS 模板 Introduce BFS template
        -   二叉搜索树 Binary Search Tree

    2016/8/13 上午9:30:00 4. 动态规划 Dynamic Programming I -<

    :  -   动态规划算法的适用条件
        -   动态规划算法的四个解题要素
        -   动规的两种实现方式：记忆化搜索 vs 循环递推
        -   面试中动态规划的常见类型
        -   坐标型动态规划

    2016/8/14 上午9:30:00 5. 动态规划 Dynamic Programming II -<

    :   -   单序列动态规划（下） Sequnece DP
        -   双序列动态规划 Two Sequences DP

    2016/8/20 上午9:30:00 6. 链表 Linked List -<

    :   -   介绍 Dummy Node 在链表问题中的运用 Introduce Dummy Node in Linked List
        -   你必须知道的几点 Linked List 的常用技巧 Basic skills in Linked List you
            should know
        -   两根指针算法 Two pointers
        -   常见问题讲解 Frequent Questions

    2016/8/21 上午9:30:00 7. 数组与数 Array & Numbers -<

    :   -   旋转排序数组相关问题与三步翻转法的运用 Rotated Sorted Array & 3-step Reversion
        -   两个排序数组的中位数 Median of Two Sorted Array
        -   子数组相关问题 SubArray
        -   两根指针与 x-sum 问题 Two Pointers & x-sum
        -   分割数组相关问题 Partition Array

    2016/8/27 上午9:30:00 8. 数据结构 Data Structure -<

    :   -   线性数据结构
            -   队列的原理、实现和运用 Queue
            -   栈的原理、实现和运用 Heap
            -   哈希表的原理、实现和运用 HashMap
        -   树形数据结构
            -   堆的原理、实现和运用 Heap

    2016/8/28 上午9:30:00 9. 图与搜索 Graph & Search -<

    :   -   图上的宽度优先搜索 Graph BFS
        -   拓扑排序 Topological Sorting
        -   组合类深度优先搜索 Combination Related DFS
        -   排列类深度优先搜索 Permutation Related DFS

[九章算法强化班 - 硅谷顶尖IT企业一线工程师直播教学](http://www.jiuzhang.com/course/5/) -<

:   2016/8/21 上午7:00:00 FLAG算法面试难度提高？如何准备？【免费试听】 -<

    :   -   各类 IT 企业的面试算法难度及风格
        -   如何解决中等难度以上的算法题
        -   如何解决 follow  up 问题
        -   Two sum
            -   1. Two sum follow up I
            -   2. Two sum follow up II - Triangle count
        -   Kth largest element
            -   1. 第 k 大元素的三层递进面试考察.
            -   2. 如何通过一道题区分 3 类面试者
            -   3. 剖析面试官面试的思路

    2016/8/28 上午7:00:00 数据结构 Data Structure (上) -<

    :   -   并查集
            -   1. 并查集的基本原理
            -   2.并查集的相关运用
        -   并查集的拓展（带路径压缩）
        -   并查集的运用
        -   Trie 树
            -   1. Trie 树的相关运用
        -   扫描线算法
            -   1. 扫描线的常规题目
            -   2. 扫描线和其他数据结构结合的拓展

    2016/8/29 上午7:00:00 数据结构 Data Structure (下) -<

    :   -   Heap的深入理解和运用
        -   Heap重要拓展：
            -   1. 带删除的堆hash-heap
            -   2. Trapping rain water
            -   3. Building Outline
        -   Median 问题拓展
        -   Sliding Windows问题总结
        -   双端队列Deque

    2016/9/4 上午7:00:00 两个指针 Two Pointers -<

    :   -   对撞型指针
            -   1. Two sum 类
            -   2. Partition 类
        -   前向型指针
            -   1. 窗口类
            -   2. 快慢类
        -   两个数组上的指针

    2016/9/5 上午7:00:00 动态规划 Dynamic Programming (上) -<

    :   -   记忆化搜索（区间动态规划、博弈类动态规划）
        -   背包类动态规划
        -   区间类动态规划

    2016/9/11 上午7:00:00 动态规划 Dynamic Programming (下) -<

    :   -   记忆化搜索拓展
            -   1. 区间动态规划
            -   2. 博弈类动态规划
        -   背包类动态规划
            -   1. BackPack I/II
            -   2. K sum
            -   3. Minimum Adjustment Cost

    2016/9/12 上午7:00:00 如何解决 follow up 问题 -<

    :   -   Peak Element I/II
        -   第 K 大
            -   1. 第 K 大
            -   2. 有序矩阵的第 K 大
            -   3. 两个数组乘积的第 K 大
            -   4. n 个数组第 K 大
            -   5. n 个数组多机第 K 大 (K 比较小)
            -   6. n 个数组多机第 K 大 (K 比较大)
        -   Subarray sum
            -   1. Subarray sum
            -   2. Submatrix sum
            -   3. Subarray Sum Closest
            -   4. Subarray sum II

[VisuAlgo - visualising data structures and algorithms through animation](http://visualgo.net/) -<

:   nice site.

    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-17-58-bubble.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-19-47-select.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-22-49-insert.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-24-32-merge.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-25-47-quick.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-26-57-rquick.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-28-54-count.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-34-41-radix.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-45-26-create-binary-heap-Onlgn.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-46-26-create-binary-heap-On.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-52-11-heap-sort.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-58-31-pred.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_10-59-12-next.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_11-04-07.gif)
    ![](http://whudoc.qiniudn.com/2016/2016-08-06_11-05-11-avl-balanced.gif)
    ![](http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-07-06.png)
    ![](http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-07-22.png)
    ![](http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-08-17.png)
    ![](http://whudoc.qiniudn.com/2016/firefox_2016-08-06_11-08-42.png)

## 3.

常见 C/C++ 函数 -<

:   -   `size_t strlen( const char *str )`{.cpp} -<

        :   ```cpp
            size_t strlen( const char *str )
            {
                const char *s = str;
                while( *s ) { ++s; }
                return s-str;
            }
            ```

            不要把 `while( *s ) { ++s; }` 写成 `while( *s++ ) { }`

            然而这里却可以把 `++` 写在 while 的判断里面：

            ```cpp
            size_t strlen( const char *str )
            {
                size_t i = 0;
                while( *str++ ) { ++i; }
                return i;
            }
            ```

            函数签名可以在 `man strlen` 或者 `man 3 strlen` 看到。

    -   `char * strcpy( char *to, const char *from )`{.cpp} -<

        :   ```cpp
            char * strcpy( char *to, const char *from  )
            {
                if ( !from && !to ) { return NULL; }
                char *p = to;
                while( (*p++=*from++) != 0 ) { }
                return to;
            }
            ```

            前面的判断似乎多余，因为我们不关心 to 是否有空间以及它原来的内容，
            我们也不需要知道 from 是否为 NULL（如果 NULL，那在 while 里面复制一
            个 NULL 就结束，也是符合预期的。）

    -   `int atoi( const char *str)`{.cpp} -<

        :   ```cpp
            int atoi( const char *str )
            {
                // TODO: handle overflow
                if ( !str ) { return 0; }

                int len = strlen( str );
                int sign = 1;

                const char *p = str;
                while ( *p == ' ' ) {
                    ++p;
                }

                if ( *p == '+' ) { sign = +1; ++p; }
                if ( *p == '-' ) { sign = -1; ++p; }

                int i = 0;
                while( p && '0' <= *p && *p <= '9' ) {
                    i = i * 10 + (*p - '0');
                    ++p;
                }

                return i*sign;
            }
            ```

    -   `const char * convert( char buf[], int value )`{.cpp} -<

        :   ```cpp
            #include <iostream>
            #include <algorithm>
            #include <stdio.h>

            const char* convert( char buf[], int value )
            {
                static char digits[19] =
                { '9', '8', '7', '6', '5', '4', '3', '2', '1', '0',
                    '1', '2', '3', '4', '5', '6', '7', '8', '9' };
                static const char *const zero = digits + 9; // zero 指向 '0'
                // works for -2147483648 .. 2147483647
                int i = value;
                char* p = buf;
                do {
                    // lsd - least significant digit
                    int lsd = i % 10; // lsd 可能小于 0
                    // 是向下取整还是向零取整?
                    *p++ = zero[lsd]; // 下标可能为负
                    i /= 10;
                } while (i != 0);
                if (value < 0) {
                    *p++ = '-';
                }
                *p = '\0';
                std::reverse(buf, p);
                return p; // p - buf 即为整数长度
            }

            int main() {
                char buf[50];
                int num;
                while( 1 == scanf( "%d", &num ) ) {
                    convert( buf, num );
                    printf( "%d -> \"%s\"\n", num, buf );
                }
            }
            ```

            上面的代码来自 chenshuo，但我总觉得这 19 个 digits 把事情弄复杂了。
            我的策略是，负数我就把它先转成正数：

            ```cpp
            const char* convert( char buf[], int value )
            {
                if( value < 0 ) {
                    buf[0] = '-';
                    return convert( buf+1, -value );
                }

                static char zero[10] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };

                char* p = buf;
                do {
                    *p++ = zero[value%10];
                    value /= 10;
                } while (value != 0);
                *p = '\0';
                std::reverse(buf, p);
                return p;
            }
            ```

    -   `char * strchr( const char *s, int c )`{.cpp} -<

        :   ```cpp
            char * strchr( const char *s, int c )
            {
                while( *s ) {
                    if( *s == c ) {
                        return s;
                    } else {
                        ++s;
                    }
                }
                return s;
            }
            ```

            目测没有 bug。懒得测了。

    -   TODO: strncpy, strcmp, strcat -<

        :   ```cpp
            char * __cdecl strcat (char * dst,const char * src)
            {
                char * cp = dst;

                while( *cp )
                    cp++;                   /* find end of dst */

                while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

                return( dst );                  /* return dst */

            }

            int __cdecl strcmp (const char * src,const char * dst)
            {
                int ret = 0 ;

                while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
                    ++src, ++dst;

                if ( ret < 0 )
                    ret = -1 ;
                else if ( ret > 0 )
                    ret = 1 ;

                return( ret );
            }

            size_t __cdecl strlen (const char * str)
            {
                const char *eos = str;

                while( *eos++ ) ;

                return( (int)(eos - str - 1) );
            }

            char * __cdecl strncat (char * front,const char * back,size_t count)
            {
                char *start = front;

                while (*front++)
                    ;
                front--;

                while (count--)
                    if (!(*front++ = *back++))
                        return(start);

                    *front = '\0';
                    return(start);
            }

            int __cdecl strncmp (const char * first,const char * last,size_t count)
            {
                if (!count)
                    return(0);

                while (--count && *first && *first == *last)
                {
                    first++;
                    last++;
                }

                return( *(unsigned char *)first - *(unsigned char *)last );
            }

            /* Copy SRC to DEST.  */
            char *
            strcpy (dest, src)
            char *dest;
            const char *src;
            {
                reg_char c;
                char *__unbounded s = (char *__unbounded) CHECK_BOUNDS_LOW (src);
                const ptrdiff_t off = CHECK_BOUNDS_LOW (dest) - s - 1;
                size_t n;

                do
                {
                    c = *s++;
                    s[off] = c;
                }
                while (c != '\0');

                n = s - src;
                (void) CHECK_BOUNDS_HIGH (src + n);
                (void) CHECK_BOUNDS_HIGH (dest + n);

                return dest;
            }

            char * __cdecl strncpy (char * dest,const char * source,size_t count)
            {
                char *start = dest;

                while (count && (*dest++ = *source++))    /* copy string */
                    count--;

                if (count)                              /* pad out with zeroes */
                    while (--count)
                        *dest++ = '\0';

                    return(start);
            }
            ```

        refs and see also

            -   [程序员编程艺术：第四章、现场编写类似strstr/strcpy/strpbrk的函数 - 结构之法 算法之道 - 博客频道 - CSDN.NET](http://blog.csdn.net/v_JULY_v/article/details/6417600)

[程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦 - 结构之法 算法之道 - 博客频道 - CSDN.NET](http://blog.csdn.net/v_july_v/article/details/6543438)
